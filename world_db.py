import pickle
import struct
import numpy
import os
#database interface
import lmdb

# local imports
from config import SECTOR_SIZE, SECTOR_HEIGHT, LOADED_SECTORS
from util import normalize, sectorize
from blocks import BLOCK_ID

class SectorDB(object):
    def __init__(self, filename, map_size=1 << 30):
        self.env = lmdb.open(
            filename,
            map_size=map_size,
            subdir=False,
            lock=True,
            max_dbs=1,
        )
        self._wtxn = None
        self._wcount = 0
        self._autocommit_every = 0  # 0 = off

    # --- batching control ---
    def begin_write_batch(self, autocommit_every=0):
        """
        Start a long-lived write transaction.
        autocommit_every: commit and reopen every N puts (helps avoid huge txns).
        """
        if self._wtxn is not None:
            return
        self._autocommit_every = int(autocommit_every) if autocommit_every else 0
        self._wcount = 0
        self._wtxn = self.env.begin(write=True)

    def commit_write_batch(self):
        if self._wtxn is None:
            return
        self._wtxn.commit()
        self._wtxn = None
        self._wcount = 0

    def abort_write_batch(self):
        if self._wtxn is None:
            return
        self._wtxn.abort()
        self._wtxn = None
        self._wcount = 0

    # --- existing API ---
    def put_sector(self, position, data):
        k = self.sector_position_to_string(position).encode("utf-8")
        v = pickle.dumps(data, -1)

        # If batching is enabled, reuse the txn; otherwise do per-call txn.
        if self._wtxn is not None:
            self._wtxn.put(k, v)
            self._wcount += 1
            if self._autocommit_every and (self._wcount % self._autocommit_every == 0):
                # commit + reopen to keep transactions bounded
                self._wtxn.commit()
                self._wtxn = self.env.begin(write=True)
            return

        with self.env.begin(write=True) as txn:
            txn.put(k, v)

    def _key(self, key):
        if isinstance(key, bytes):
            return key
        return str(key).encode("utf-8")

    def get(self, key):
        k = self._key(key)
        with self.env.begin(write=False) as txn:
            value = txn.get(k)
        if value is None:
            raise KeyError(key)
        return pickle.loads(value)

    def put(self, key, value):
        k = self._key(key)
        v = pickle.dumps(value, -1)
        with self.env.begin(write=True) as txn:
            txn.put(k, v)
        return True

    def get_sector(self, position):
        k = self._key(self.sector_position_to_string(position))
        with self.env.begin(write=False) as txn:
            value = txn.get(k)
        if value is None:
            return None
        return pickle.loads(value)

    def string_to_sector_position(self, str_position):
        p = str_position.split(':')
        return (p[0], 0, p[1])

    def sector_position_to_string(self, sector_position):
        return str(sector_position[0]) + ':' + str(sector_position[2])

class Sector(object):
    def __init__(self, position, db):
        self.db = db
        if self.db is not None:
            self.blocks = self.db.get_sector(position)
        else:
            self.blocks = None
        self.position = position[0],0,position[2]
        self.bposition = position[0]-1,0,position[2]-1 #block relative position (the sector is overgenerated by one block along each x,z edge)

#        self.vt_data = None
#        self.exposed = None

    def __getitem__(self, position):
        pos = position - numpy.array(self.bposition)
        if len(pos.shape)>1:
            pos = pos.T
            return self.blocks[pos[0],pos[1],pos[2]]
        return self.blocks[pos[0],pos[1],pos[2]]

    def __setitem__(self, position, value):
        pos = position - numpy.array(self.bposition)
        if len(pos.shape)>1:
            pos = pos.T
        if self.blocks == None:
            self.blocks = {}
        self.blocks[pos[0],pos[1],pos[2]] = value
        if self.db is not None:
            self.db.put_sector(self.position, self.blocks)

    def set_block(self, position, block_id):
        """ Set a block in the sector at `position` to `block_id`.

        Parameters
        ----------
        position : tuple of len 3
            The (x, y, z) position of the block to add.
        texture : list of len 3
            The coordinates of the texture squares. Use `tex_coords()` to
            generate.
        """
        self[position] = block_id


class World(object):
    '''
    Stores data about the world
    '''

    def __init__(self):
#        mapgen.initialize_map_generator()
        # The world is stored in sector chunks.
        self.sectors = {}
        self.sector_cache = []
        self.db = SectorDB('world.db')

    def __getitem__(self, position):
        """
        retrieves the block at the (x,y,z) coordinate tuple `position`
        """
        try:
            return self.getsector(sectorize(position))[position]
        except:
            return None

    def get_sector(self, sector_position):
        sector_position = sectorize(sector_position)
        if sector_position in self.sectors:
            return self.sectors[sector_position]
        s = Sector(sector_position, self.db)
        self.sectors[sector_position] = s
        return s

    def neighbor_sectors(self, pos):
        """
        return a tuple (dx, dz, sector) of currently loaded neighbors to the sector at pos
        """
        pos = sectorize(pos)
        for x in ((-1,0),(1,0),(0,-1),(0,1)):
            npos = (pos[0]+x[0]*SECTOR_SIZE,0,pos[2]+x[1]*SECTOR_SIZE)
            if npos in self.sectors:
                yield x[0],x[1],self.sectors[npos]

    def get_sector_data(self, spos):
        #TODO: Free up unneeded sectors
        spos = sectorize(spos)
        if spos in self.sectors:
            return self.sectors[spos].blocks
        else:
            s = Sector(spos, self.db)
            self.sectors[spos] = s
            return s.blocks

    def set_block(self, position, block):
        position = normalize(position)
        spos = sectorize(position)
        result = []
        result.append(self._set_block(spos, position, block))
        if position[0] - spos[0] == 0:
            nspos = sectorize((position[0]-1, position[1], position[2]))
            result.append(self._set_block(nspos, position, block))
        if position[0] - spos[0] == SECTOR_SIZE-1:
            nspos = sectorize((position[0]+1, position[1], position[2]))
            result.append(self._set_block(nspos, position, block))
        if position[2] - spos[2] == 0:
            nspos = sectorize((position[0], position[1], position[2]-1))
            result.append(self._set_block(nspos, position, block))
        if position[2] - spos[2] == SECTOR_SIZE-1:
            nspos = sectorize((position[0], position[1], position[2]+1))
            result.append(self._set_block(nspos, position, block))
        return result

    def _set_block(self, spos, position, block):
        s = self.sectors[spos]
        s.set_block(position, block)
        return spos, s.blocks

    def get_seed(self):
        try:
            seed = int(self.db.get("world_seed"))
        except KeyError:
            seed = struct.unpack("<I", os.urandom(4))[0]
            self.db.put("world_seed", seed)
            return seed

        # HARD GUARANTEE: numpy.random.seed requires 0 <= seed <= 2**32 - 1
        seed &= 0xFFFFFFFF

        # Persist normalization if needed
        self.db.put("world_seed", seed)
        return seed
        
    def set_seed(self, seed):
        return self.db.put('world_seed', seed)
