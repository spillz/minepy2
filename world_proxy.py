# standard library imports
import math
import itertools
import time
import numpy
from collections import deque
import queue
import multiprocessing.connection
import multiprocessing.sharedctypes
import multiprocessing
try:
    import cPickle as pickle
except ImportError:
    import pickle
import gc
import concurrent.futures

#gc.set_debug(gc.DEBUG_LEAK)

# pyglet imports
import pyglet
image = pyglet.image
from pyglet.graphics import TextureGroup
from pyglet.math import Mat4
import pyglet.gl as gl


class TransparentWaterGroup(TextureGroup):
    """Texture group that disables depth writes so water stays see-through."""
    def set_state(self):
        super().set_state()
        gl.glDepthMask(gl.GL_FALSE)

    def unset_state(self):
        gl.glDepthMask(gl.GL_TRUE)
        super().unset_state()

# local imports
import world_loader
import server_connection
import config
from config import SECTOR_SIZE, SECTOR_HEIGHT, LOADED_SECTORS
from util import normalize, sectorize, FACES, cube_v, cube_v2, compute_vertex_ao
from blocks import BLOCK_VERTICES, BLOCK_COLORS, BLOCK_NORMALS, BLOCK_TEXTURES, BLOCK_ID, BLOCK_SOLID, BLOCK_OCCLUDES, BLOCK_OCCLUDES_SAME, BLOCK_GLOW, TEXTURE_PATH, BLOCK_LIGHT_LEVELS
import mapgen
import numpy

WATER = BLOCK_ID['Water']
#import logging
#logging.basicConfig(level = logging.INFO)
#def world_log(msg, *args):
#    logging.log(logging.INFO, 'WORLD: '+msg, *args)

class SectorProxy(object):
    def __init__(self, position, batch_solid, batch_water, group, water_group, model, shown=True):
        self.position = position[0],0,position[2]
        self.bposition = position[0]-1,0,position[2]-1 #block relative position (the sector is overgenerated by one block along each x,z edge)
        self.group = group
        self.water_group = water_group
        self.model = model
        # A Batch is a collection of vertex lists for batched rendering.
        self.batch = batch_solid
        self.batch_water = batch_water
        self.blocks = numpy.zeros((SECTOR_SIZE+2,SECTOR_HEIGHT,SECTOR_SIZE+2),dtype='u2')
        self.light = None  # full (padded) light grid from loader
        self.shown = shown
        # Mapping from position to a pyglet `VertextList` for all shown blocks.
        self.vt = None
        self.vt_water = None
        self.vt_data = None
        self.invalidate_vt = False
        self.needs_seam_refresh = False
        self.mesh_job_pending = False
        self.mesh_job_dirty = False
        self.mesh_gen = 0
        self.patch_vt = []
        self.edit_token = 0
        self.edit_inflight = False

    def draw(self, draw_invalid = True, allow_upload = True):
        if allow_upload and draw_invalid and self.invalidate_vt:
            self.check_show()
            self.invalidate_vt = False
            draw_invalid = False
        self.batch.draw()
        return draw_invalid

    def draw_water(self):
        """Draw only the water batch for this sector."""
        self.batch_water.draw()

    def __getitem__(self, position):
        pos = position - numpy.array(self.bposition)
        if len(pos.shape)>1:
            pos = pos.T
            return self.blocks[pos[0],pos[1],pos[2]]
        return self.blocks[pos[0],pos[1],pos[2]]

    def invalidate(self):
        self.invalidate_vt = True

    def check_show(self,add_to_batch = True):
        if add_to_batch and self.vt_data is not None:
            if self.vt is not None:
                print('deleting vt', self.position)
                self.vt.delete()
                self.vt = None
            if self.vt_water is not None:
                self.vt_water.delete()
                self.vt_water = None

            def _build_list(vt_tuple, group, batch):
                if not vt_tuple or vt_tuple[0] <= 0:
                    return None, 0
                (count, v, t, n, c) = vt_tuple
                quad_verts = numpy.array(v, dtype='f4').reshape(-1, 4, 3)
                quad_tex = numpy.array(t, dtype='f4').reshape(-1, 4, 2)
                quad_norm = numpy.array(n, dtype='f4').reshape(-1, 4, 3)
                quad_col = numpy.array(c, dtype='f4').reshape(-1, 4, int(len(c) / len(quad_verts) / 4) if len(quad_verts) else 4)
                order = [0, 1, 2, 0, 2, 3]
                tri_verts = quad_verts[:, order, :].reshape(-1, 3)
                tri_tex = quad_tex[:, order, :].reshape(-1, 2)
                tri_norm = quad_norm[:, order, :].reshape(-1, 3)
                tri_col = quad_col[:, order, :].reshape(-1, 3)
                tri_count = len(tri_verts)
                vt = self.model.program.vertex_list(
                    tri_count,
                    gl.GL_TRIANGLES,
                    batch=batch,
                    group=group,
                    position=('f', tri_verts.ravel().astype('f4')),
                    tex_coords=('f', tri_tex.ravel().astype('f4')),
                    normal=('f', tri_norm.ravel().astype('f4')),
                    color=('f', tri_col.ravel().astype('f4')),
                )
                return vt, tri_count

            t_upload_start = time.perf_counter()
            solid_data = self.model._get_vt_entry(self.vt_data, 'solid')
            water_data = self.model._get_vt_entry(self.vt_data, 'water')
            self.vt, solid_tris = _build_list(solid_data, self.group, self.batch)
            self.vt_water, water_tris = _build_list(water_data, self.water_group, self.batch_water)
            elapsed = (time.perf_counter() - t_upload_start) * 1000.0
            total_tris = solid_tris + water_tris
            print(f'[perf] upload sector {self.position} tris={total_tris} took {elapsed:.1f}ms')
            # Clear any temporary patch geometry once full mesh is uploaded.
            for pv in self.patch_vt:
                pv.delete()
            self.patch_vt.clear()
            self.vt_data = None
            self.invalidate_vt = False
        elif add_to_batch and self.vt_data is None and self.invalidate_vt:
            # Lazy rebuild when vt data was cleared for seam sync.
            self.invalidate_vt = False
            self.model._submit_mesh_job(self)
            return False


class ModelProxy(object):

    def __init__(self, program):

        # A TextureGroup manages an OpenGL texture.
        texture = image.load(TEXTURE_PATH).get_texture()
        self.program = program
        shader_group = pyglet.graphics.ShaderGroup(self.program)
        # Bind texture via TextureGroup under the shader group.
        self.group = TextureGroup(texture, parent=shader_group, order=0)
        # Water draws after opaque with depth writes disabled so the seafloor stays visible.
        self.water_group = TransparentWaterGroup(texture, parent=shader_group, order=1)
        self.unused_batches = []
        self.pending_uploads = deque()
        self.pending_upload_set = set()
        self.load_radius = getattr(config, 'LOAD_RADIUS', LOADED_SECTORS + 1)  # prefetch a wider ring
        self.keep_radius = getattr(config, 'KEEP_RADIUS', self.load_radius + 1)  # hysteresis before unloading
        self.pending_seam_rebuild = set()
        self.sector_edit_tokens = {}
        self.mesh_executor = concurrent.futures.ThreadPoolExecutor(
            max_workers=getattr(config, 'MESH_WORKERS', 2)
        )
        self.mesh_results = queue.SimpleQueue()

        # The world is stored in sector chunks.
        self.sectors = {}
        self.update_sectors_pos = []
        self.update_ref_pos = None

        self.loader_requests = []
        self.active_loader_request = [None, None]
        self.n_requests = 0
        self.n_responses = 0
        self._skip_active_sector = False  # allow dropping a long-running sector load when edits arrive

        loader_server_pipe = None
        self.server = None
        if config.DEBUG_SINGLE_BLOCK:
            # Create a single sector with one visible block for debugging.
            batch_solid, batch_water = self.get_batches()
            s = SectorProxy((0,0,0), batch_solid, batch_water, self.group, self.water_group, self, shown=True)
            s.blocks[:] = 0
            cx, cy, cz = SECTOR_SIZE//2, SECTOR_HEIGHT//2, SECTOR_SIZE//2
            block_id = 1  # dirt
            s.blocks[cx+1, cy, cz+1] = block_id
            vt_data = self._build_block_vt(block_id, numpy.array([cx, cy, cz], dtype=numpy.float32))
            s.vt_data = vt_data
            s.check_show()
            self.sectors[s.position] = s
            self.loader = None
            print(f"[DEBUG] Single block spawned at world coords {(cx, cy, cz)}")
        else:
            if config.SERVER_IP is not None:
                print ('Starting server on %s'%(config.SERVER_IP,))
                self.server = server_connection.start_server_connection(config.SERVER_IP)
                loader_server_pipe = self.server.loader_pipe
            print ('Starting sector loader')
            self.loader = world_loader.start_loader(loader_server_pipe)

    def _has_budget(self, frame_start, upload_budget):
        if frame_start is None or upload_budget is None:
            return True
        return (time.perf_counter() - frame_start) < upload_budget

    def _get_vt_entry(self, vt_data, key=None):
        """Return a single vt tuple from a dict or bare tuple."""
        if vt_data is None:
            return None
        if isinstance(vt_data, dict):
            if key is None:
                return vt_data.get('solid') or vt_data.get('water')
            return vt_data.get(key)
        return vt_data

    def _triangles_in_vt(self, vt_data):
        """Return triangle count for a vt_data tuple (quads -> tris)."""
        if not vt_data:
            return 0

        def _tri_count(entry):
            if not entry:
                return 0
            quad_count = entry[0] / 4.0
            return int(quad_count * 2)

        if isinstance(vt_data, dict):
            return _tri_count(vt_data.get('solid')) + _tri_count(vt_data.get('water'))
        return _tri_count(vt_data)

    @staticmethod
    def _build_mesh_job(blocks, light_full, position, ao_strength, ao_enabled, ambient):
        """Build vt_data for a sector snapshot; runs off the main thread."""
        # Compute exposed faces and lighting (if provided).
        # Reuse _compute_exposed logic inline to avoid touching shared state.
        air = (BLOCK_SOLID[blocks] == 0)
        solid = (blocks > 0) & (blocks != WATER)
        exposed_faces = numpy.zeros(blocks.shape + (6,), dtype=bool)
        neighbor = blocks[:,1:,:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:,:-1,:]))
        exposed_faces[:,:-1,:,0] = ~neighbor_occ
        neighbor = blocks[:,:-1,:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:,1:,:]))
        exposed_faces[:,1:,:,1] = ~neighbor_occ
        neighbor = blocks[:-1,:,:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[1:,:,:]))
        exposed_faces[1:,:,:,2] = ~neighbor_occ
        neighbor = blocks[1:,:,:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:-1,:,:]))
        exposed_faces[:-1,:,:,3] = ~neighbor_occ
        neighbor = blocks[:,:,1:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:,:,:-1]))
        exposed_faces[:,:,:-1,4] = ~neighbor_occ
        neighbor = blocks[:,:,:-1]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:,:,1:]))
        exposed_faces[:,:,1:,5] = ~neighbor_occ
        exposed_faces = exposed_faces & solid[..., None]

        if light_full is None:
            light = numpy.zeros(blocks.shape, dtype=numpy.float32)
            decay = getattr(config, 'LIGHT_DECAY', 0.75)
            top_y = blocks.shape[1] - 1
            for x in range(blocks.shape[0]):
                for z in range(blocks.shape[2]):
                    for y in range(top_y, -1, -1):
                        if air[x, y, z]:
                            light[x, y, z] = 1.0
                        else:
                            break
            block_emitters = BLOCK_LIGHT_LEVELS or {}
            for bid, lvl in block_emitters.items():
                emitters = numpy.argwhere(blocks == bid)
                for ex, ey, ez in emitters:
                    light[ex, ey, ez] = max(light[ex, ey, ez], float(lvl))
            diag_decay = decay * math.sqrt(2.0)
            corner_decay = decay * math.sqrt(3.0)
            for _ in range(64):
                neighbor_max = numpy.zeros_like(light)
                neighbor_max[:-1,:,:] = numpy.maximum(neighbor_max[:-1,:,:], light[1:,:,:] - decay)
                neighbor_max[1:,:,:]  = numpy.maximum(neighbor_max[1:,:,:],  light[:-1,:,:] - decay)
                neighbor_max[:,:-1,:] = numpy.maximum(neighbor_max[:,:-1,:], light[:,1:,:] - decay)
                neighbor_max[:,1:,:]  = numpy.maximum(neighbor_max[:,1:,:],  light[:,:-1,:] - decay)
                neighbor_max[:,:,:-1] = numpy.maximum(neighbor_max[:,:,:-1], light[:,:,1:] - decay)
                neighbor_max[:,:,1:]  = numpy.maximum(neighbor_max[:,:,1:],  light[:,:,:-1] - decay)
                neighbor_max[:-1,:-1,:] = numpy.maximum(neighbor_max[:-1,:-1,:], light[1:,1:,:] - diag_decay)
                neighbor_max[:-1,1:,:]  = numpy.maximum(neighbor_max[:-1,1:,:],  light[1:,:-1,:] - diag_decay)
                neighbor_max[1:,:-1,:]  = numpy.maximum(neighbor_max[1:,:-1,:],  light[:-1,1:,:] - diag_decay)
                neighbor_max[1:,1:,:]   = numpy.maximum(neighbor_max[1:,1:,:],   light[:-1,:-1,:] - diag_decay)
                neighbor_max[:-1,:,:-1] = numpy.maximum(neighbor_max[:-1,:,:-1], light[1:,:,1:] - diag_decay)
                neighbor_max[:-1,:,1:]  = numpy.maximum(neighbor_max[:-1,:,1:],  light[1:,:,:-1] - diag_decay)
                neighbor_max[1:,:,:-1]  = numpy.maximum(neighbor_max[1:,:,:-1],  light[:-1,:,1:] - diag_decay)
                neighbor_max[1:,:,1:]   = numpy.maximum(neighbor_max[1:,:,1:],   light[:-1,:,:-1] - diag_decay)
                neighbor_max[:,:-1,:-1] = numpy.maximum(neighbor_max[:,:-1,:-1], light[:,1:,1:] - diag_decay)
                neighbor_max[:,1:,:-1]  = numpy.maximum(neighbor_max[:,1:,:-1],  light[:,:-1,1:] - diag_decay)
                neighbor_max[:,:-1,1:]  = numpy.maximum(neighbor_max[:,:-1,1:],  light[:,1:,:-1] - diag_decay)
                neighbor_max[:,1:,1:]   = numpy.maximum(neighbor_max[:,1:,1:],   light[:,:-1,:-1] - diag_decay)
                neighbor_max[:-1,:-1,:-1] = numpy.maximum(neighbor_max[:-1,:-1,:-1], light[1:,1:,1:] - corner_decay)
                neighbor_max[:-1,:-1,1:]  = numpy.maximum(neighbor_max[:-1,:-1,1:],  light[1:,1:,:-1] - corner_decay)
                neighbor_max[:-1,1:,:-1]  = numpy.maximum(neighbor_max[:-1,1:,:-1],  light[1:,:-1,1:] - corner_decay)
                neighbor_max[:-1,1:,1:]   = numpy.maximum(neighbor_max[:-1,1:,1:],   light[1:,:-1,:-1] - corner_decay)
                neighbor_max[1:,:-1,:-1] = numpy.maximum(neighbor_max[1:,:-1,:-1], light[:-1,1:,1:] - corner_decay)
                neighbor_max[1:,:-1,1:]  = numpy.maximum(neighbor_max[1:,:-1,1:],  light[:-1,1:,:-1] - corner_decay)
                neighbor_max[1:,1:,:-1]  = numpy.maximum(neighbor_max[1:,1:,:-1],  light[:-1,:-1,1:] - corner_decay)
                neighbor_max[1:,1:,1:]   = numpy.maximum(neighbor_max[1:,1:,1:],   light[:-1,:-1,:-1] - corner_decay)
                new_light = numpy.where(air, numpy.maximum(light, neighbor_max), 0.0)
                if numpy.array_equal(new_light, light):
                    break
                light = new_light
            light_full = light

        exposed_light = numpy.zeros(blocks.shape+(6,),dtype=numpy.float32)
        exposed_light[:,:-1,:,0] = light_full[:,1:,:] # up
        exposed_light[:,1:,:,1] = light_full[:,:-1,:] # down
        exposed_light[1:,:,:,2] = light_full[:-1,:,:] # left
        exposed_light[:-1,:,:,3] = light_full[1:,:,:] # right
        exposed_light[:,:,:-1,4] = light_full[:,:,1:] # front
        exposed_light[:,:,1:,5] = light_full[:,:,:-1] # back

        exposed_faces = exposed_faces[1:-1,:,1:-1]
        exposed_light = exposed_light[1:-1,:,1:-1]

        sx, sy, sz, _ = exposed_faces.shape
        face_mask = exposed_faces.reshape(sx*sy*sz, 6)
        light_flat = exposed_light.reshape(sx*sy*sz, 6)
        block_mask = face_mask.any(axis=1)
        ao = None
        if ao_enabled and block_mask.any():
            ao = compute_vertex_ao(
                BLOCK_SOLID[blocks].astype(bool),
                (sx, sy, sz),
                ao_strength,
                block_mask=block_mask,
            )
        v = numpy.array([], dtype=numpy.float32)
        t = numpy.array([], dtype=numpy.float32)
        n = numpy.array([], dtype=numpy.float32)
        c = numpy.array([], dtype=numpy.float32)
        count = 0
        sector_grid = numpy.indices((SECTOR_SIZE, SECTOR_HEIGHT, SECTOR_SIZE)).transpose(1,2,3,0).reshape((SECTOR_SIZE*SECTOR_HEIGHT*SECTOR_SIZE,3))
        if block_mask.any():
            pos = sector_grid[block_mask] + numpy.array(position)
            face_mask = face_mask[block_mask]
            light_flat = light_flat[block_mask]
            b = blocks[1:-1,:,1:-1].reshape(sx*sy*sz)[block_mask]
            verts = (0.5*BLOCK_VERTICES[b].reshape(len(b),6,4,3) + pos[:,None,None,:]).astype(numpy.float32)
            tex = BLOCK_TEXTURES[b][:,:6].reshape(len(b),6,4,2).astype(numpy.float32)
            normals = numpy.broadcast_to(BLOCK_NORMALS[None,:,None,:], (len(b),6,4,3)).astype(numpy.float32)
            colors_base = BLOCK_COLORS[b][:,:6].reshape(len(b),6,4,3).astype(numpy.float32)
            light = light_flat[:, :, None, None]  # (N,6,1,1)
            colors_lit = colors_base * (ambient + (1.0 - ambient) * light)
            if ao is not None:
                ao_flat = numpy.where(face_mask[..., None], ao, 1.0)
                colors_lit = colors_lit * ao_flat[..., None]
            # Glow acts as a minimum brightness floor after AO.
            if BLOCK_GLOW is not None:
                glow = BLOCK_GLOW[b][:, None, None, None]
                if numpy.any(glow > 0):
                    colors_lit = numpy.maximum(colors_lit, colors_base * glow)
            emissive = BLOCK_GLOW[b][:, None, None, None] * 255.0
            emissive = numpy.broadcast_to(emissive, colors_lit.shape[:-1] + (1,))
            colors_rgba = numpy.concatenate([colors_lit, emissive], axis=3)
            colors = numpy.clip(colors_rgba, 0, 255)
            v = verts[face_mask].reshape(-1,3).ravel()
            t = tex[face_mask].reshape(-1,2).ravel()
            n = normals[face_mask].reshape(-1,3).ravel()
            c = colors[face_mask].reshape(-1,4).ravel()
            count = len(v)//3
        water_blocks = (blocks == WATER)
        water_exposed = numpy.zeros(blocks.shape + (6,), dtype=bool)
        neighbor = blocks[:,1:,:]
        air = (neighbor != WATER) & (BLOCK_SOLID[neighbor] == 0)
        water_exposed[:,:-1,:,0] = water_blocks[:,:-1,:] & air
        neighbor = blocks[:,:-1,:]
        air = (neighbor != WATER) & (BLOCK_SOLID[neighbor] == 0)
        water_exposed[:,1:,:,1] = water_blocks[:,1:,:] & air
        neighbor = blocks[:-1,:,:]
        air = (neighbor != WATER) & (BLOCK_SOLID[neighbor] == 0)
        water_exposed[1:,:,:,2] = water_blocks[1:,:,:] & air
        neighbor = blocks[1:,:,:]
        air = (neighbor != WATER) & (BLOCK_SOLID[neighbor] == 0)
        water_exposed[:-1,:,:,3] = water_blocks[:-1,:,:] & air
        neighbor = blocks[:,:,1:]
        air = (neighbor != WATER) & (BLOCK_SOLID[neighbor] == 0)
        water_exposed[:,:,:-1,4] = water_blocks[:,:,:-1] & air
        neighbor = blocks[:,:,:-1]
        air = (neighbor != WATER) & (BLOCK_SOLID[neighbor] == 0)
        water_exposed[:,:,1:,5] = water_blocks[:,:,1:] & air

        water_exposed = water_exposed[1:-1,:,1:-1]
        w_face_mask = water_exposed.reshape(sx*sy*sz, 6)
        water_mask = w_face_mask.any(axis=1)
        if water_mask.any():
            pos_w = sector_grid[water_mask] + numpy.array(position)
            face_mask_w = w_face_mask[water_mask]
            b = numpy.full(len(pos_w), WATER, dtype=numpy.int32)
            verts = (0.5*BLOCK_VERTICES[b].reshape(len(b),6,4,3) + pos_w[:,None,None,:]).astype(numpy.float32)
            tex = BLOCK_TEXTURES[b][:,:6].reshape(len(b),6,4,2).astype(numpy.float32)
            normals = numpy.broadcast_to(BLOCK_NORMALS[None,:,None,:], (len(b),6,4,3)).astype(numpy.float32)
            colors = BLOCK_COLORS[b][:,:6].reshape(len(b),6,4,3).astype(numpy.float32)

            face_verts = verts[face_mask_w].reshape(-1,4,3)
            face_tex = tex[face_mask_w].reshape(-1,4,2)
            face_norm = normals[face_mask_w].reshape(-1,4,3)
            face_col = colors[face_mask_w].reshape(-1,4,3)
            emissive_w = numpy.zeros(face_col.shape[:-1] + (1,), dtype=face_col.dtype)
            face_col = numpy.concatenate([face_col, emissive_w], axis=2)

            wv = face_verts.reshape(-1,3).ravel()
            wtcoords = face_tex.reshape(-1,2).ravel()
            wn = face_norm.reshape(-1,3).ravel()
            wc = face_col.reshape(-1,4).ravel()
            water_count = len(wv) // 3
            water_data = (water_count, wv, wtcoords, wn, wc)
        else:
            water_data = None
        solid_data = (count, v, t, n, c)
        return {'solid': solid_data, 'water': water_data}

    def _queue_upload(self, sector, priority=False):
        """Queue a sector for upload/rebuild; avoid reshuffling if already queued."""
        if sector in self.pending_upload_set:
            return
        self.pending_upload_set.add(sector)
        if priority:
            self.pending_uploads.appendleft(sector)
        else:
            self.pending_uploads.append(sector)

    def _submit_mesh_job(self, sector):
        """Kick off an async mesh build for this sector."""
        if sector.mesh_job_pending or (sector.vt_data is not None and not sector.invalidate_vt):
            sector.mesh_job_dirty = True
            return
        sector.mesh_job_pending = True
        sector.mesh_job_dirty = False
        sector.mesh_gen += 1
        blocks = sector.blocks.copy()
        light_copy = sector.light.copy() if sector.light is not None else None
        ao_strength = getattr(config, 'AO_STRENGTH', 0.0)
        ao_enabled = getattr(config, 'AO_ENABLED', True)
        ambient = getattr(config, 'AMBIENT_LIGHT', 0.0)
        gen = sector.mesh_gen
        pos = sector.position

        def _done(fut):
            self.mesh_results.put(fut)
        future = self.mesh_executor.submit(
            self._build_mesh_job,
            blocks,
            light_copy,
            pos,
            ao_strength,
            ao_enabled,
            ambient,
        )
        future.gen = gen
        future.pos = pos
        future.add_done_callback(_done)

    def _drain_mesh_results(self):
        """Consume finished mesh jobs and enqueue uploads if still valid."""
        while not self.mesh_results.empty():
            fut = self.mesh_results.get_nowait()
            try:
                vt_data = fut.result()
            except Exception as e:
                print('[mesh] job failed', e)
                continue
            pos = getattr(fut, 'pos', None)
            gen = getattr(fut, 'gen', None)
            if pos is None:
                continue
            sector = self.sectors.get(pos)
            if sector is None:
                continue
            sector.mesh_job_pending = False
            if sector.mesh_job_dirty:
                sector.mesh_job_dirty = False
                self._submit_mesh_job(sector)
                continue
            if gen is not None and sector.mesh_gen != gen:
                # stale result
                continue
            sector.vt_data = vt_data
            sector.invalidate()
            if sector.shown:
                self._queue_upload(sector)

    def process_pending_uploads(self, frame_start=None, upload_budget=None, uploaded_tris=0, tri_budget=None):
        """Upload queued sector vertex data while budget remains."""
        while self.pending_uploads and self._has_budget(frame_start, upload_budget):
            s = self.pending_uploads.popleft()
            self.pending_upload_set.discard(s)
            if s.vt_data is not None:
                tri_count = self._triangles_in_vt(s.vt_data)
                over_time = not self._has_budget(frame_start, upload_budget)
                over_tris = tri_budget is not None and (uploaded_tris + tri_count) > tri_budget
                if over_time or over_tris:
                    # Not enough budget left; try next frame.
                    self._queue_upload(s)
                    break
                s.check_show(add_to_batch=True)
                uploaded_tris += tri_count
            elif s.invalidate_vt:
                s.check_show(add_to_batch=True)
                s.invalidate_vt = False
        return uploaded_tris

    def _compute_exposed(self, blocks):
        # Occlusion mask: general occluders + same-type occluders (e.g., leaves occlude leaves).
        air = (BLOCK_SOLID[blocks] == 0)
        solid = (blocks > 0) & (blocks != WATER)
        exposed_faces = numpy.zeros(blocks.shape + (6,), dtype=bool)
        # up (+y)
        neighbor = blocks[:,1:,:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:,:-1,:]))
        exposed_faces[:,:-1,:,0] = ~neighbor_occ
        # down (-y)
        neighbor = blocks[:,:-1,:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:,1:,:]))
        exposed_faces[:,1:,:,1] = ~neighbor_occ
        # left (-x)
        neighbor = blocks[:-1,:,:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[1:,:,:]))
        exposed_faces[1:,:,:,2] = ~neighbor_occ
        # right (+x)
        neighbor = blocks[1:,:,:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:-1,:,:]))
        exposed_faces[:-1,:,:,3] = ~neighbor_occ
        # forward (+z)
        neighbor = blocks[:,:,1:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:,:,:-1]))
        exposed_faces[:,:,:-1,4] = ~neighbor_occ
        # back (-z)
        neighbor = blocks[:,:,:-1]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:,:,1:]))
        exposed_faces[:,:,1:,5] = ~neighbor_occ

        exposed_faces = exposed_faces & solid[..., None]

        # Recompute baked lighting locally (skylight + optional block emitters)
        light = numpy.zeros(blocks.shape, dtype=numpy.float32)
        decay = getattr(config, 'LIGHT_DECAY', 0.75)
        top_y = blocks.shape[1] - 1
        # Skylight pass: no decay straight down until blocked.
        for x in range(blocks.shape[0]):
            for z in range(blocks.shape[2]):
                for y in range(top_y, -1, -1):
                    if air[x, y, z]:
                        light[x, y, z] = 1.0
                    else:
                        break
        # Block light emitters
        block_emitters = BLOCK_LIGHT_LEVELS or {}
        for bid, lvl in block_emitters.items():
            emitters = numpy.argwhere(blocks == bid)
            for ex, ey, ez in emitters:
                light[ex, ey, ez] = max(light[ex, ey, ez], float(lvl))

        diag_decay = decay * math.sqrt(2.0)
        corner_decay = decay * math.sqrt(3.0)
        for _ in range(64):
            neighbor_max = numpy.zeros_like(light)
            # Axis neighbors
            neighbor_max[:-1,:,:] = numpy.maximum(neighbor_max[:-1,:,:], light[1:,:,:] - decay)   # +x
            neighbor_max[1:,:,:]  = numpy.maximum(neighbor_max[1:,:,:],  light[:-1,:,:] - decay)  # -x
            neighbor_max[:,:-1,:] = numpy.maximum(neighbor_max[:,:-1,:], light[:,1:,:] - decay)   # +y
            neighbor_max[:,1:,:]  = numpy.maximum(neighbor_max[:,1:,:],  light[:,:-1,:] - decay)  # -y
            neighbor_max[:,:,:-1] = numpy.maximum(neighbor_max[:,:,:-1], light[:,:,1:] - decay)   # +z
            neighbor_max[:,:,1:]  = numpy.maximum(neighbor_max[:,:,1:],  light[:,:,:-1] - decay)  # -z
            # Edge diagonals (sqrt(2) cost)
            neighbor_max[:-1,:-1,:] = numpy.maximum(neighbor_max[:-1,:-1,:], light[1:,1:,:] - diag_decay)
            neighbor_max[:-1,1:,:]  = numpy.maximum(neighbor_max[:-1,1:,:],  light[1:,:-1,:] - diag_decay)
            neighbor_max[1:,:-1,:]  = numpy.maximum(neighbor_max[1:,:-1,:],  light[:-1,1:,:] - diag_decay)
            neighbor_max[1:,1:,:]   = numpy.maximum(neighbor_max[1:,1:,:],   light[:-1,:-1,:] - diag_decay)

            neighbor_max[:-1,:,:-1] = numpy.maximum(neighbor_max[:-1,:,:-1], light[1:,:,1:] - diag_decay)
            neighbor_max[:-1,:,1:]  = numpy.maximum(neighbor_max[:-1,:,1:],  light[1:,:,:-1] - diag_decay)
            neighbor_max[1:,:,:-1]  = numpy.maximum(neighbor_max[1:,:,:-1],  light[:-1,:,1:] - diag_decay)
            neighbor_max[1:,:,1:]   = numpy.maximum(neighbor_max[1:,:,1:],   light[:-1,:,:-1] - diag_decay)

            neighbor_max[:,:-1,:-1] = numpy.maximum(neighbor_max[:,:-1,:-1], light[:,1:,1:] - diag_decay)
            neighbor_max[:,1:,:-1]  = numpy.maximum(neighbor_max[:,1:,:-1],  light[:,:-1,1:] - diag_decay)
            neighbor_max[:,:-1,1:]  = numpy.maximum(neighbor_max[:,:-1,1:],  light[:,1:,:-1] - diag_decay)
            neighbor_max[:,1:,1:]   = numpy.maximum(neighbor_max[:,1:,1:],   light[:,:-1,:-1] - diag_decay)
            # Corner diagonals (sqrt(3) cost)
            neighbor_max[:-1,:-1,:-1] = numpy.maximum(neighbor_max[:-1,:-1,:-1], light[1:,1:,1:] - corner_decay)
            neighbor_max[:-1,:-1,1:]  = numpy.maximum(neighbor_max[:-1,:-1,1:],  light[1:,1:,:-1] - corner_decay)
            neighbor_max[:-1,1:,:-1]  = numpy.maximum(neighbor_max[:-1,1:,:-1],  light[1:,:-1,1:] - corner_decay)
            neighbor_max[:-1,1:,1:]   = numpy.maximum(neighbor_max[:-1,1:,1:],   light[1:,:-1,:-1] - corner_decay)

            neighbor_max[1:,:-1,:-1] = numpy.maximum(neighbor_max[1:,:-1,:-1], light[:-1,1:,1:] - corner_decay)
            neighbor_max[1:,:-1,1:]  = numpy.maximum(neighbor_max[1:,:-1,1:],  light[:-1,1:,:-1] - corner_decay)
            neighbor_max[1:,1:,:-1]  = numpy.maximum(neighbor_max[1:,1:,:-1],  light[:-1,:-1,1:] - corner_decay)
            neighbor_max[1:,1:,1:]   = numpy.maximum(neighbor_max[1:,1:,1:],   light[:-1,:-1,:-1] - corner_decay)

            new_light = numpy.where(air, numpy.maximum(light, neighbor_max), 0.0)
            if numpy.array_equal(new_light, light):
                break
            light = new_light

        exposed_light = numpy.zeros(blocks.shape+(6,),dtype=numpy.float32)
        exposed_light[:,:-1,:,0] = light[:,1:,:] # up
        exposed_light[:,1:,:,1] = light[:,:-1,:] # down
        exposed_light[1:,:,:,2] = light[:-1,:,:] # left
        exposed_light[:-1,:,:,3] = light[1:,:,:] # right
        exposed_light[:,:,:-1,4] = light[:,:,1:] # front
        exposed_light[:,:,1:,5] = light[:,:,:-1] # back
        return exposed_faces, exposed_light

    def _recompute_vt(self, sector):
        ao_strength = getattr(config, 'AO_STRENGTH', 0.0)
        # Prefer loader-provided light field to avoid recomputing flood-fill on the client.
        if sector.light is not None:
            blocks = sector.blocks
            light_full = sector.light
            solid = (blocks > 0) & (blocks != WATER)
            exposed_faces = numpy.zeros(blocks.shape + (6,), dtype=bool)
            def neighbor_occ_mask(cur_block, neighbor_block):
                solid_occ = BLOCK_SOLID[neighbor_block] != 0
                same_occ = (BLOCK_OCCLUDES_SAME[neighbor_block] != 0) & (neighbor_block == cur_block)
                return solid_occ | same_occ
            neighbor = blocks[:,1:,:]
            exposed_faces[:,:-1,:,0] = ~neighbor_occ_mask(blocks[:,:-1,:], neighbor)
            neighbor = blocks[:,:-1,:]
            exposed_faces[:,1:,:,1] = ~neighbor_occ_mask(blocks[:,1:,:], neighbor)
            neighbor = blocks[:-1,:,:]
            exposed_faces[1:,:,:,2] = ~neighbor_occ_mask(blocks[1:,:,:], neighbor)
            neighbor = blocks[1:,:,:]
            exposed_faces[:-1,:,:,3] = ~neighbor_occ_mask(blocks[:-1,:,:], neighbor)
            neighbor = blocks[:,:,1:]
            exposed_faces[:,:,:-1,4] = ~neighbor_occ_mask(blocks[:,:,:-1], neighbor)
            neighbor = blocks[:,:,:-1]
            exposed_faces[:,:,1:,5] = ~neighbor_occ_mask(blocks[:,:,1:], neighbor)
            exposed_faces = exposed_faces & solid[..., None]

            exposed_light = numpy.zeros(blocks.shape+(6,),dtype=numpy.float32)
            exposed_light[:,:-1,:,0] = light_full[:,1:,:] # up
            exposed_light[:,1:,:,1] = light_full[:,:-1,:] # down
            exposed_light[1:,:,:,2] = light_full[:-1,:,:] # left
            exposed_light[:-1,:,:,3] = light_full[1:,:,:] # right
            exposed_light[:,:,:-1,4] = light_full[:,:,1:] # front
            exposed_light[:,:,1:,5] = light_full[:,:,:-1] # back
        else:
            exposed_faces, exposed_light = self._compute_exposed(sector.blocks)

        exposed_faces = exposed_faces[1:-1,:,1:-1]
        exposed_light = exposed_light[1:-1,:,1:-1]

        sx, sy, sz, _ = exposed_faces.shape
        face_mask = exposed_faces.reshape(sx*sy*sz, 6)
        light_flat = exposed_light.reshape(sx*sy*sz, 6)
        block_mask = face_mask.any(axis=1)
        ao = None
        if getattr(config, 'AO_ENABLED', True) and block_mask.any():
            ao = compute_vertex_ao(
                BLOCK_SOLID[sector.blocks].astype(bool),
                (sx, sy, sz),
                ao_strength,
                block_mask=block_mask,
            )
        v = numpy.array([], dtype=numpy.float32)
        t = numpy.array([], dtype=numpy.float32)
        n = numpy.array([], dtype=numpy.float32)
        c = numpy.array([], dtype=numpy.float32)
        count = 0
        sector_grid = numpy.indices((SECTOR_SIZE, SECTOR_HEIGHT, SECTOR_SIZE)).transpose(1,2,3,0).reshape((SECTOR_SIZE*SECTOR_HEIGHT*SECTOR_SIZE,3))
        if block_mask.any():
            pos = sector_grid[block_mask] + numpy.array(sector.position)
            face_mask = face_mask[block_mask]
            light_flat = light_flat[block_mask]
            b = sector.blocks[1:-1,:,1:-1].reshape(sx*sy*sz)[block_mask]
            verts = (0.5*BLOCK_VERTICES[b].reshape(len(b),6,4,3) + pos[:,None,None,:]).astype(numpy.float32)
            tex = BLOCK_TEXTURES[b][:,:6].reshape(len(b),6,4,2).astype(numpy.float32)
            normals = numpy.broadcast_to(BLOCK_NORMALS[None,:,None,:], (len(b),6,4,3)).astype(numpy.float32)
            colors_base = BLOCK_COLORS[b][:,:6].reshape(len(b),6,4,3).astype(numpy.float32)
            ambient = getattr(config, 'AMBIENT_LIGHT', 0.0)
            light = light_flat[:, :, None, None]  # (N,6,1,1)
            colors_lit = colors_base * (ambient + (1.0 - ambient) * light)
            if ao is not None:
                ao_flat = numpy.where(face_mask[..., None], ao, 1.0)
                colors_lit = colors_lit * ao_flat[..., None]
            if BLOCK_GLOW is not None:
                glow = BLOCK_GLOW[b][:, None, None, None]
                if numpy.any(glow > 0):
                    colors_lit = numpy.maximum(colors_lit, colors_base * glow)
            emissive = BLOCK_GLOW[b][:, None, None, None] * 255.0
            emissive = numpy.broadcast_to(emissive, colors_lit.shape[:-1] + (1,))
            colors_rgba = numpy.concatenate([colors_lit, emissive], axis=3)
            colors = numpy.clip(colors_rgba, 0, 255)
            v = verts[face_mask].reshape(-1,3).ravel()
            t = tex[face_mask].reshape(-1,2).ravel()
            n = normals[face_mask].reshape(-1,3).ravel()
            c = colors[face_mask].reshape(-1,4).ravel()
            count = len(v)//3
        # Water geometry: exposed faces of water blocks, duplicated for visibility above/below.
        water_blocks = (sector.blocks == WATER)
        water_exposed = numpy.zeros(sector.blocks.shape + (6,), dtype=bool)
        neighbor = sector.blocks[:,1:,:]
        water_exposed[:,:-1,:,0] = water_blocks[:,:-1,:] & (neighbor != WATER)
        neighbor = sector.blocks[:,:-1,:]
        water_exposed[:,1:,:,1] = water_blocks[:,1:,:] & (neighbor != WATER)
        neighbor = sector.blocks[:-1,:,:]
        water_exposed[1:,:,:,2] = water_blocks[1:,:,:] & (neighbor != WATER)
        neighbor = sector.blocks[1:,:,:]
        water_exposed[:-1,:,:,3] = water_blocks[:-1,:,:] & (neighbor != WATER)
        neighbor = sector.blocks[:,:,1:]
        water_exposed[:,:,:-1,4] = water_blocks[:,:,:-1] & (neighbor != WATER)
        neighbor = sector.blocks[:,:,:-1]
        water_exposed[:,:,1:,5] = water_blocks[:,:,1:] & (neighbor != WATER)

        water_exposed = water_exposed[1:-1,:,1:-1]
        w_face_mask = water_exposed.reshape(sx*sy*sz, 6)
        water_mask = w_face_mask.any(axis=1)
        if water_mask.any():
            pos_w = sector_grid[water_mask] + numpy.array(sector.position)
            face_mask_w = w_face_mask[water_mask]
            b = numpy.full(len(pos_w), WATER, dtype=numpy.int32)
            verts = (0.5*BLOCK_VERTICES[b].reshape(len(b),6,4,3) + pos_w[:,None,None,:]).astype(numpy.float32)
            tex = BLOCK_TEXTURES[b][:,:6].reshape(len(b),6,4,2).astype(numpy.float32)
            normals = numpy.broadcast_to(BLOCK_NORMALS[None,:,None,:], (len(b),6,4,3)).astype(numpy.float32)
            colors = BLOCK_COLORS[b][:,:6].reshape(len(b),6,4,3).astype(numpy.float32)

            face_verts = verts[face_mask_w].reshape(-1,4,3)
            face_tex = tex[face_mask_w].reshape(-1,4,2)
            face_norm = normals[face_mask_w].reshape(-1,4,3)
            face_col = colors[face_mask_w].reshape(-1,4,3)
            emissive_w = numpy.zeros(face_col.shape[:-1] + (1,), dtype=face_col.dtype)
            face_col = numpy.concatenate([face_col, emissive_w], axis=2)

            wv = face_verts.reshape(-1,3).ravel()
            wtcoords = face_tex.reshape(-1,2).ravel()
            wn = face_norm.reshape(-1,3).ravel()
            wc = face_col.reshape(-1,4).ravel()
            water_count = len(wv)//3
            water_data = (water_count, wv, wtcoords, wn, wc)
        else:
            water_data = None
        solid_data = (count, v, t, n, c)
        sector.vt_data = {'solid': solid_data, 'water': water_data}
        sector.invalidate()

    def _sync_edges_and_rebuild(self, sector):
        # Copy boundary columns between this sector and loaded neighbors, then queue rebuilds.
        require_diag = getattr(config, 'SEAM_REQUIRE_DIAGONALS', False)
        if not self._neighbors_ready(sector, require_diag):
            # Defer until neighbors are available.
            self.pending_seam_rebuild.add(sector.position)
            return
        self.pending_seam_rebuild.discard(sector.position)
        neighbors = list(self.neighbor_sectors(sector.position))
        for dx, dz, n in neighbors:
            if dx == 1:
                # neighbor to the east
                n.blocks[0,:,:] = sector.blocks[SECTOR_SIZE,:,:]
                sector.blocks[SECTOR_SIZE+1,:,:] = n.blocks[1,:,:]
                if n.light is not None and sector.light is not None:
                    n.light[0,:,:] = sector.light[SECTOR_SIZE,:,:]
                    sector.light[SECTOR_SIZE+1,:,:] = n.light[1,:,:]
            elif dx == -1:
                n.blocks[SECTOR_SIZE+1,:,:] = sector.blocks[1,:,:]
                sector.blocks[0,:,:] = n.blocks[SECTOR_SIZE,:,:]
                if n.light is not None and sector.light is not None:
                    n.light[SECTOR_SIZE+1,:,:] = sector.light[1,:,:]
                    sector.light[0,:,:] = n.light[SECTOR_SIZE,:,:]
            if dz == 1:
                # neighbor to the south (positive z)
                n.blocks[:,:,0] = sector.blocks[:,:,SECTOR_SIZE]
                sector.blocks[:,:,SECTOR_SIZE+1] = n.blocks[:,:,1]
                if n.light is not None and sector.light is not None:
                    n.light[:,:,0] = sector.light[:,:,SECTOR_SIZE]
                    sector.light[:,:,SECTOR_SIZE+1] = n.light[:,:,1]
            elif dz == -1:
                n.blocks[:,:,SECTOR_SIZE+1] = sector.blocks[:,:,1]
                sector.blocks[:,:,0] = n.blocks[:,:,SECTOR_SIZE]
                if n.light is not None and sector.light is not None:
                    n.light[:,:,SECTOR_SIZE+1] = sector.light[:,:,1]
                    sector.light[:,:,0] = n.light[:,:,SECTOR_SIZE]
            n.vt_data = None
            n.invalidate()
            if n.shown:
                self._submit_mesh_job(n)
            else:
                n.needs_seam_refresh = True
        sector.vt_data = None
        sector.invalidate()
        if sector.shown:
            # Self rebuild with normal priority to minimize reordering churn.
            self._submit_mesh_job(sector)
        else:
            sector.needs_seam_refresh = True
        sector.needs_seam_refresh = False

    def set_matrices(self, projection, view, camera_pos):
        # Convert pyglet Mat4 to column-major numpy arrays
        proj = numpy.array(list(projection), dtype='f4').reshape((4, 4), order='F')
        view_mat = numpy.array(list(view), dtype='f4').reshape((4, 4), order='F')

        # The view matrix from look_at already has the translation.
        # The shader also applies translation via u_camera_pos.
        # To avoid double-correction, we remove the translation from the view matrix
        # and rely on the shader's relative positioning.
        view_mat[3, :3] = 0.0
        
        # Shader expects flat (1D) arrays
        self.program['u_projection'] = proj.ravel(order='F')
        self.program['u_view'] = view_mat.ravel(order='F')
        self.program['u_camera_pos'] = tuple(camera_pos) # Pass eye position
        
        # Set model matrix to identity for world rendering
        self.program['u_model'] = Mat4()

    def get_batches(self):
        if len(self.unused_batches)>0:
            return self.unused_batches.pop(0)
        else:
            return (pyglet.graphics.Batch(), pyglet.graphics.Batch())

    def release_sector(self, sector):
        # Drop any pending uploads for this sector before freeing GPU buffers.
        self.pending_upload_set.discard(sector)
        try:
            self.pending_uploads.remove(sector)
        except ValueError:
            pass
        self.pending_seam_rebuild.discard(sector.position)
        if sector.vt is not None:
            sector.vt.delete()
            sector.vt = None
        if getattr(sector, 'vt_water', None) is not None:
            sector.vt_water.delete()
            sector.vt_water = None
        sector.vt_data = None
        sector.mesh_job_pending = False
        sector.mesh_job_dirty = False
        sector.patch_vt = []
        self.unused_batches.append((sector.batch, sector.batch_water))
        del self.sectors[sector.position]

    def __getitem__(self, position):
        """
        retrieves the block at the (x,y,z) coordinate tuple `position`
        """
        try:
            return self.sectors[sectorize(position)][position]
        except:
            return None

    def get_vertical_column(self, x, z):
        """
        Return the full column of blocks at integer (x,z) coordinates, or None
        if the corresponding sector is not loaded.
        """
        sx = sectorize((x, 0, z))
        sector = self.sectors.get(sx)
        if sector is None:
            return None
        ix = int(round(x)) - (sector.position[0] - 1)
        iz = int(round(z)) - (sector.position[2] - 1)
        if not (0 <= ix < config.SECTOR_SIZE + 2 and 0 <= iz < config.SECTOR_SIZE + 2):
            return None
        return sector.blocks[ix, :, iz]

    def add_block(self, position, block, notify_server = True):
        spos = sectorize(position)
        if spos in self.sectors:
            s = self.sectors[spos]
            # Apply locally for instant feedback
            rel = numpy.array(position) - numpy.array(s.position) + numpy.array([1,0,1])
            try:
                s.blocks[rel[0], rel[1], rel[2]] = block
            except Exception:
                pass
            s.invalidate_vt = True
            self._submit_mesh_job(s)
            s.edit_inflight = True
            blocks = s.blocks
            sector_data = [(spos, blocks)]
            for np in [(1,0,0), (-1,0,0), (0,0,1), (0,0,-1)]:
                nspos = sectorize((position[0]+np[0],position[1]+np[1],position[2]+np[2]))
                if nspos != spos and nspos in self.sectors:
                    nblocks = self.sectors[nspos].blocks
                    sector_data.append((nspos, nblocks))
            # Purge queued background sector loads so edits jump the line.
            self.loader_requests = [req for req in self.loader_requests if req[0] != 'sector_blocks']
            # If the loader is busy with a sector load, mark it as skippable once it returns.
            if self.active_loader_request[0] == 'sector_blocks':
                self._skip_active_sector = True
            s.edit_token += 1
            self.sector_edit_tokens[spos] = s.edit_token
            self.loader_requests.insert(0,['set_block', [notify_server, position, block, sector_data, s.edit_token]])
            # Immediate visual patch
            for pv in s.patch_vt:
                pv.delete()
            s.patch_vt = []
            if block != 0:
                world_pos = numpy.array(position, dtype=float)
                vt = self._build_block_vt(block, world_pos)
                key = 'water' if block == WATER else 'solid'
                tri_verts, tri_tex, tri_norm, tri_col = self._triangulate_vt(vt, key)
                if len(tri_verts) > 0:
                    group = s.water_group if block == WATER else s.group
                    batch = s.batch_water if block == WATER else s.batch
                    patch = self.program.vertex_list(
                        len(tri_verts),
                        gl.GL_TRIANGLES,
                        batch=batch,
                        group=group,
                        position=('f', tri_verts.ravel().astype('f4')),
                        tex_coords=('f', tri_tex.ravel().astype('f4')),
                        normal=('f', tri_norm.ravel().astype('f4')),
                        color=('f', tri_col.ravel().astype('f4')),
                    )
                    s.patch_vt.append(patch)

    def remove_block(self, position, notify_server = True):
        pos = normalize(position)
        existing = self[pos]
        if existing == WATER:
            if not self._can_remove_water(pos):
                return
        self.add_block(pos, 0)
        # If we removed terrain below the waterline and there's adjacent water, flow in.
        if existing != WATER and pos[1] < self._water_level():
            if any(self[normalize((pos[0]+dx, pos[1]+dy, pos[2]+dz))] == WATER for dx, dy, dz in FACES):
                self.add_block(pos, WATER, notify_server)

    def _can_remove_water(self, pos):
        """Allow removal only if water pocket is smaller than 4 contiguous blocks."""
        seen = set()
        q = [pos]
        water_count = 0
        while q:
            cur = q.pop()
            if cur in seen:
                continue
            seen.add(cur)
            if self[cur] != WATER:
                continue
            water_count += 1
            if water_count >= 4:
                return False
            cx, cy, cz = cur
            for dx, dy, dz in FACES:
                npos = (cx + dx, cy + dy, cz + dz)
                if npos not in seen:
                    q.append(npos)
        return True

    def _water_level(self):
        return getattr(mapgen, 'GLOBAL_WATER_LEVEL', getattr(mapgen, 'WATER_LEVEL', 70))

    def draw(self, position, frustum_circle, frame_start=None, upload_budget=None, defer_uploads=False):
        """Draw only sectors intersecting the current view frustum projection. Limit or defer GPU uploads to respect frame budget."""
        draw_invalid = True
        uploaded_tris = 0
        tri_budget = getattr(config, 'UPLOAD_TRIANGLE_BUDGET', None)
        # Default to opaque pass.
        self.program['u_water_pass'] = False
        # Keep alpha synced with config in case it changes.
        self.program['u_water_alpha'] = getattr(config, 'WATER_ALPHA', 0.8)

        def budget_ok():
            return self._has_budget(frame_start, upload_budget)

        for s in self.sectors.values():
            visible = self._sector_overlaps_frustum(s.position, frustum_circle)
            s.shown = visible
            if visible and s.needs_seam_refresh:
                s.needs_seam_refresh = False
                self._sync_edges_and_rebuild(s)
            if not visible:
                continue

            uploaded = False
            # Try to upload fresh vt_data if allowed; otherwise queue it.
            if s.vt_data is not None:
                tri_count = self._triangles_in_vt(s.vt_data)
                over_tris = tri_budget is not None and (uploaded_tris + tri_count) > tri_budget
                over_time = not budget_ok()
                if not defer_uploads and not over_time and not over_tris:
                    s.check_show(add_to_batch=True)
                    self.pending_upload_set.discard(s)
                    uploaded = True
                    uploaded_tris += tri_count
                else:
                    self._queue_upload(s)
            # Handle invalidated buffers (edge sync) within the budget or queue.
            elif draw_invalid and s.invalidate_vt:
                if not defer_uploads and budget_ok():
                    s.check_show(add_to_batch=True)
                    s.invalidate_vt = False
                    uploaded = True
                else:
                    self._queue_upload(s)

            if uploaded:
                draw_invalid = False
            # Draw existing batch; skip uploads here to honor the budget.
            draw_invalid = s.draw(draw_invalid, allow_upload=False)

        # Drain async mesh results before uploads.
        self._drain_mesh_results()
        # Drain pending uploads while budget remains (only when not deferring).
        if not defer_uploads:
            uploaded_tris = self.process_pending_uploads(frame_start, upload_budget, uploaded_tris, tri_budget)
        # Transparent water draws after all opaque uploads/draws so depth writes stay intact.
        self.program['u_water_pass'] = True
        gl.glEnable(gl.GL_BLEND)
        gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)
        cull_enabled = gl.glIsEnabled(gl.GL_CULL_FACE)
        if cull_enabled:
            gl.glDisable(gl.GL_CULL_FACE)
        gl.glDepthMask(gl.GL_FALSE)  # depth test stays on; just stop writing so opaque depth survives
        for s in self.sectors.values():
            if s.shown:
                s.draw_water()
        gl.glDepthMask(gl.GL_TRUE)
        if cull_enabled:
            gl.glEnable(gl.GL_CULL_FACE)
        self.program['u_water_pass'] = False

    def neighbor_sectors(self, pos):
        """
        return a tuple (dx, dz, sector) of currently loaded neighbors to the sector at pos
        """
        pos = sectorize(pos)
        for x in ((-1,0),(1,0),(0,-1),(0,1)):
            npos = (pos[0]+x[0]*SECTOR_SIZE,0,pos[2]+x[1]*SECTOR_SIZE)
            if npos in self.sectors:
                yield x[0],x[1],self.sectors[npos]

    def _sector_overlaps_frustum(self, sector_pos, frustum_circle):
        """Return True if the sector AABB intersects the 2D frustum circle."""
        if not frustum_circle:
            return True
        (center, rad) = frustum_circle
        cx, cz = center
        min_x = sector_pos[0] - 1
        max_x = sector_pos[0] + SECTOR_SIZE + 1
        min_z = sector_pos[2] - 1
        max_z = sector_pos[2] + SECTOR_SIZE + 1
        # Clamp circle center to sector bounds to find closest point
        nearest_x = min(max(cx, min_x), max_x)
        nearest_z = min(max(cz, min_z), max_z)
        dx = cx - nearest_x
        dz = cz - nearest_z
        return (dx * dx + dz * dz) <= (rad * rad)

    def _sector_priority(self, ref_sector, sector_pos, player_pos, look_vec):
        """Weight sector load priority by distance and look direction."""
        dist = (sector_pos[0] - ref_sector[0]) ** 2 + (sector_pos[2] - ref_sector[2]) ** 2
        if player_pos is None or look_vec is None:
            return float(dist)
        view = numpy.array([look_vec[0], look_vec[2]], dtype=float)
        vnorm = numpy.linalg.norm(view)
        if vnorm < 1e-5:
            return float(dist)
        view /= vnorm
        sector_center = numpy.array([sector_pos[0] + SECTOR_SIZE / 2.0,
                                     sector_pos[2] + SECTOR_SIZE / 2.0],
                                    dtype=float)
        to_sector = sector_center - numpy.array([player_pos[0], player_pos[2]], dtype=float)
        tnorm = numpy.linalg.norm(to_sector)
        if tnorm < 1e-5:
            facing = 1.0
        else:
            to_sector /= tnorm
            facing = float(numpy.dot(view, to_sector))
        angle_penalty = 1.0 - facing  # 0 front, 2 back
        return float(dist + angle_penalty * (SECTOR_SIZE ** 2))

    def _neighbors_ready(self, sector, require_diagonals=False):
        """Return True if the cardinal (and optionally diagonal) neighbors are loaded."""
        x0, _, z0 = sector.position
        card = [
            (x0 + SECTOR_SIZE, 0, z0),
            (x0 - SECTOR_SIZE, 0, z0),
            (x0, 0, z0 + SECTOR_SIZE),
            (x0, 0, z0 - SECTOR_SIZE),
        ]
        for p in card:
            if p not in self.sectors:
                return False
        if not require_diagonals:
            return True
        diag = [
            (x0 + SECTOR_SIZE, 0, z0 + SECTOR_SIZE),
            (x0 + SECTOR_SIZE, 0, z0 - SECTOR_SIZE),
            (x0 - SECTOR_SIZE, 0, z0 + SECTOR_SIZE),
            (x0 - SECTOR_SIZE, 0, z0 - SECTOR_SIZE),
        ]
        return all(p in self.sectors for p in diag)

    def _process_pending_seams(self, max_count=None):
        """Try to rebuild any sectors that were waiting for neighbors."""
        if not self.pending_seam_rebuild:
            return
        require_diag = getattr(config, 'SEAM_REQUIRE_DIAGONALS', False)
        processed = 0
        # Iterate over a copy to allow removal during rebuild.
        for pos in list(self.pending_seam_rebuild):
            if max_count is not None and processed >= max_count:
                break
            s = self.sectors.get(pos)
            if s is None:
                self.pending_seam_rebuild.discard(pos)
                continue
            if not s.shown:
                s.needs_seam_refresh = True
                continue
            if self._neighbors_ready(s, require_diag):
                self._sync_edges_and_rebuild(s)
                processed += 1
        # Clean up fulfilled entries
        for pos in list(self.pending_seam_rebuild):
            s = self.sectors.get(pos)
            if s and not s.needs_seam_refresh and self._neighbors_ready(s, require_diag):
                self.pending_seam_rebuild.discard(pos)

    def update_sectors(self, old, new, player_pos=None, look_vec=None):
        """
        the observer has moved from sector old to new
        """
        if self.n_requests <= self.n_responses:
            new = sectorize(new)
            if self.update_ref_pos != new:
                self.update_ref_pos = new
                self.update_sectors_pos = []
                load_radius = max(self.load_radius, LOADED_SECTORS)
                keep_radius = max(self.keep_radius, load_radius)
                G = range(-load_radius, load_radius+1)
                for dx,dy,dz in itertools.product(G,(0,),G):
                    pos = numpy.array([new[0],new[1],new[2]]) \
                        + numpy.array([dx*SECTOR_SIZE,dy,dz*SECTOR_SIZE])
                    pos = sectorize(pos)
                    priority = self._sector_priority(new, pos, player_pos, look_vec)
                    if pos not in self.sectors and pos != self.active_loader_request[1]:
                        self.update_sectors_pos.append((priority,pos))
                for s in list(self.sectors):
                    if abs(new[0] - s[0])>keep_radius*SECTOR_SIZE or abs(new[2] - s[2]) > keep_radius*SECTOR_SIZE:
                        print('dropping sector',s,len(self.sectors))
                        self.release_sector(self.sectors[s])
                self.update_sectors_pos = sorted(self.update_sectors_pos)
            # If player edits are queued, defer background loads until they flush.
            pending_edit = any(r[0] == 'set_block' for r in self.loader_requests)
            if not pending_edit and len(self.update_sectors_pos)>0:
                self.active_loader_request = self.update_sectors_pos.pop(0)
                spos = self.active_loader_request[1]
                print('queueing sector',spos)
                try:
                    req_pos = [r[0] for r in self.loader_requests].index('sector_blocks') #insert job below higher priority jobs
                except ValueError:
                    req_pos = -1
                self.loader_requests.insert(req_pos,['sector_blocks',[spos]])
            if len(self.loader_requests)>0:
                self.loader_time = time.time()
                self.n_requests += 1
                print('client sending request to loader',self.loader_requests[0][0])
                self.loader.send(self.loader_requests.pop(0))

        if self.loader.poll():
            try:
                recv_start = time.perf_counter()
                raw = self.loader.recv()
                recv_ms = (time.perf_counter() - recv_start) * 1000.0
                # Allow either (msg, data) tuples or variable-length lists.
                msg, data = None, None
                if isinstance(raw, (list, tuple)) and len(raw) > 0:
                    msg = raw[0]
                    if len(raw) == 2:
                        data = raw[1]
                    else:
                        data = raw[1:]
                else:
                    print('client recv unexpected payload', raw)
                print(f'client received {msg} in {recv_ms:.1f}ms')
                if msg == 'sector_blocks':
                    spos1, b1, v1, light1 = data
                    self.n_responses = self.n_requests
                    self.active_loader_request = [None, None]
                    print('took', time.time()-self.loader_time)
                    if self._skip_active_sector:
                        # Drop long-running background work when edits demand priority.
                        print('skipping sector result due to pending edits', spos1)
                        self._skip_active_sector = False
                    else:
                        self._update_sector(spos1, b1, v1, light1)
                if msg == 'sector_blocks2':
                    self.n_responses = self.n_requests
                    self.active_loader_request = [None, None]
                    print('took', time.time()-self.loader_time)
                    # sector_blocks2 payload may be [sector_results, token] or just sector_results
                    token = None
                    sector_results = data
                    if isinstance(data, (list, tuple)) and len(data) == 2 and isinstance(data[1], int):
                        sector_results, token = data
                    for item in sector_results:
                        spos, b, v, light = item
                        if token is not None:
                            # Drop stale responses superseded by newer edits.
                            if self.sector_edit_tokens.get(spos, 0) != token:
                                continue
                        self._update_sector(spos, b, v, light)
                # After processing loader message, drain a limited number of pending seam rebuilds to avoid bursts.
                max_seams = getattr(config, 'MAX_SEAM_REBUILDS_PER_TICK', None)
                self._process_pending_seams(max_seams)
            except EOFError:
                print('loader returned EOF')

        if self.server and self.server.poll():
            try:
                msg, data = self.server.recv()
                if msg == 'connected':
                    self.player, self.players = data
                if msg == 'player_set_block':
                    print(data)
                    pos, block = data
                    self.add_block(pos, block, False)
            except EOFError:
                print('server returned EOF')

    def _build_block_vt(self, block_id, pos):
        verts = (0.5*BLOCK_VERTICES[block_id][:6].reshape(6,4,3) + pos[None,None,:]).astype(numpy.float32)
        tex = BLOCK_TEXTURES[block_id][:6].reshape(6,4,2).astype(numpy.float32)
        normals = numpy.broadcast_to(BLOCK_NORMALS[:,None,:], (6,4,3)).astype(numpy.float32)
        colors_rgb = BLOCK_COLORS[block_id][:6].reshape(6,4,3).astype(numpy.float32)
        emissive = numpy.full((6,4,1), BLOCK_GLOW[block_id]*255.0, dtype=numpy.float32)
        colors = numpy.concatenate([colors_rgb, emissive], axis=2)
        face_mask = numpy.ones((6,4), dtype=bool)
        v = verts[face_mask].reshape(-1,3).ravel().astype('f4')
        t = tex[face_mask].reshape(-1,2).ravel().astype('f4')
        n = normals[face_mask].reshape(-1,3).ravel().astype('f4')
        c = colors[face_mask].reshape(-1,4).ravel().astype('f4')
        count = len(v)//3
        if config.DEBUG_SINGLE_BLOCK:
            print("[DEBUG] block vertex sample:", v[:18], "tex:", t[:8])
        solid = (count, v, t, n, c)
        return {'solid': solid, 'water': None}

    def _triangulate_vt(self, vt_data, key=None):
        """Convert quad vt_data to triangle arrays."""
        vt_tuple = self._get_vt_entry(vt_data, key)
        if not vt_tuple or vt_tuple[0] <= 0:
            return (numpy.array([], dtype='f4').reshape(0, 3),
                    numpy.array([], dtype='f4').reshape(0, 2),
                    numpy.array([], dtype='f4').reshape(0, 3),
                    numpy.array([], dtype='f4').reshape(0, 3))
        count, v, t, n, c = vt_tuple
        quad_verts = numpy.array(v, dtype='f4').reshape(-1, 4, 3)
        quad_tex = numpy.array(t, dtype='f4').reshape(-1, 4, 2)
        quad_norm = numpy.array(n, dtype='f4').reshape(-1, 4, 3)
        channels = int(len(c) // len(quad_verts) // 4) if len(quad_verts) else 3
        quad_col = numpy.array(c, dtype='f4').reshape(-1, 4, channels)
        order = [0, 1, 2, 0, 2, 3]
        tri_verts = quad_verts[:, order, :].reshape(-1, 3)
        tri_tex = quad_tex[:, order, :].reshape(-1, 2)
        tri_norm = quad_norm[:, order, :].reshape(-1, 3)
        tri_col = quad_col[:, order, :].reshape(-1, channels)
        return tri_verts, tri_tex, tri_norm, tri_col

    def _update_sector(self, spos, b, v, light):
        if b is not None:
            if spos in self.sectors:
                print('updating existing sector data',spos)
                s = self.sectors[spos]
                s.blocks[:,:,:] = b
                s.light = light
                s.vt_data = v
                self._sync_edges_and_rebuild(s)
            else:
                print('setting new sector data',spos)
                batch_solid, batch_water = self.get_batches()
                s = SectorProxy(spos, batch_solid, batch_water, self.group, self.water_group, self)
                s.blocks[:,:,:] = b
                s.light = light
                s.vt_data = v
                self.sectors[sectorize(spos)] = s
                self._sync_edges_and_rebuild(s)
        # A new/updated sector may unblock pending seam rebuilds.
        max_seams = getattr(config, 'MAX_SEAM_REBUILDS_PER_TICK', None)
        self._process_pending_seams(max_seams)

    def hit_test(self, position, vector, max_distance=8):
        """ Line of sight search from current position. If a block is
        intersected it is returned, along with the block previously in the line
        of sight. If no block is found, return None, None.

        Parameters
        ----------
        position : tuple of len 3
            The (x, y, z) position to check visibility from.
        vector : tuple of len 3
            The line of sight vector.
        max_distance : int
            How many blocks away to search for a hit.

        """
        m = 8
        x, y, z = position
        dx, dy, dz = vector
        previous = None
        for _ in range(max_distance * m):
            key = normalize((x, y, z))
            if key != previous:
                b = self[key]
                # Treat water as transparent for interaction; keep searching for solid terrain.
                if b != 0 and b is not None and b != WATER:
                    return key, previous
            previous = key
            x, y, z = x + dx / m, y + dy / m, z + dz / m
        return None, None

    def measure_void_distance(self, position, vector, max_distance=64):
        """Return the number of solid blocks after the first hit until air along a ray.

        Starts from the current sight line, finds the first solid block, then steps
        block-by-block along the ray direction until the first air/void cell or until
        max_distance is exceeded. Returns None when no initial hit is found.
        """
        hit, _ = self.hit_test(position, vector, max_distance=max_distance)
        if not hit:
            return None

        hx, hy, hz = hit
        dx, dy, dz = vector
        length = math.sqrt(dx * dx + dy * dy + dz * dz)
        if length == 0:
            return None
        dirx, diry, dirz = dx / length, dy / length, dz / length

        # Start at center of hit block to avoid immediately re-hitting it.
        cellx, celly, cellz = hx, hy, hz
        px, py, pz = hx + 0.5, hy + 0.5, hz + 0.5
        step_x = 1 if dirx >= 0 else -1
        step_y = 1 if diry >= 0 else -1
        step_z = 1 if dirz >= 0 else -1

        invx = 1.0 / dirx if dirx != 0 else float("inf")
        invy = 1.0 / diry if diry != 0 else float("inf")
        invz = 1.0 / dirz if dirz != 0 else float("inf")

        t_max_x = ((cellx + (1 if step_x > 0 else 0)) - px) * invx if invx != float("inf") else float("inf")
        t_max_y = ((celly + (1 if step_y > 0 else 0)) - py) * invy if invy != float("inf") else float("inf")
        t_max_z = ((cellz + (1 if step_z > 0 else 0)) - pz) * invz if invz != float("inf") else float("inf")

        t_delta_x = abs(invx)
        t_delta_y = abs(invy)
        t_delta_z = abs(invz)

        traveled_blocks = 0
        t = 0.0
        max_steps = int(math.ceil(max_distance)) + 2

        for _ in range(max_steps):
            # advance to next voxel boundary
            if t_max_x < t_max_y:
                if t_max_x < t_max_z:
                    cellx += step_x
                    t = t_max_x
                    t_max_x += t_delta_x
                else:
                    cellz += step_z
                    t = t_max_z
                    t_max_z += t_delta_z
            else:
                if t_max_y < t_max_z:
                    celly += step_y
                    t = t_max_y
                    t_max_y += t_delta_y
                else:
                    cellz += step_z
                    t = t_max_z
                    t_max_z += t_delta_z

            if t > max_distance:
                break
            block = self[(cellx, celly, cellz)]
            if block == 0 or block is None:
                return traveled_blocks
            traveled_blocks += 1

        return traveled_blocks

    def nearest_mushroom_in_sector(self, sector_pos, player_pos=None):
        """Return nearest mushroom world coords inside a loaded sector, or None."""
        mush_id = BLOCK_ID.get('Mushroom')
        if mush_id is None:
            return None
        sector = self.sectors.get(sector_pos)
        if sector is None or sector.blocks is None:
            return None
        coords = numpy.argwhere(sector.blocks == mush_id)
        if coords.size == 0:
            return None
        if player_pos is None:
            player_pos = (sector_pos[0], 0, sector_pos[2])
        px, py, pz = player_pos
        best = None
        best_d2 = None
        for cx, cy, cz in coords:
            wx = sector_pos[0] + int(cx) - 1
            wy = int(cy)
            wz = sector_pos[2] + int(cz) - 1
            dx = wx - px
            dy = wy - py
            dz = wz - pz
            d2 = dx*dx + dy*dy + dz*dz
            if best is None or d2 < best_d2:
                best = (wx, wy, wz)
                best_d2 = d2
        return best

    def exposed(self, position):
        """ Returns False is given `position` is surrounded on all 6 sides by
        blocks, True otherwise.

        """
        x, y, z = position
        for dx, dy, dz in FACES:
            b = self[normalize((x + dx, y + dy, z + dz))]
            if not BLOCK_SOLID[b]:
                return True
        return False

    def collide(self, position, bounding_box):
        """
        Checks to see if an entity at the given `position` with the given
        `bounding_box` is colliding with any blocks in the world.

        Parameters
        ----------
        position : tuple of len 3
            The (x, y, z) position to check for collisions at.
        bounding_box : tuple of len 3
            The (width, height, depth) of the entity.

        Returns
        -------
        position : tuple of len 3
            The new position of the entity taking into account collisions.
        vertical_collision : bool
            True if the entity collided with the ground or ceiling.
        """
        # TODO: Add bounding box support to collision
        height = int(bounding_box[1])
        pad = 0.1
        p = list(position)
        np = normalize(position)
        vertical_collision = False
        for face in FACES:  # check all surrounding blocks
            for i in range(3):  # check each dimension independently
                if not face[i]:
                    continue
                # How much overlap you have with this dimension.
                d = (p[i] - np[i]) * face[i]
                if d < pad:
                    continue
                for dy in range(height):  # check each height
                    op = list(np)
                    op[1] -= dy
                    op[i] += face[i]
                    b = self[normalize(op)]
                    if b is None or b == 0 or not BLOCK_SOLID[b]:
                        continue
                    p[i] -= (d - pad) * face[i]
                    if face[1] != 0: # y-axis collision
                        vertical_collision = True
                    break
        return tuple(p), vertical_collision

    def quit(self,kill_server=True):
        if self.n_requests > self.n_responses:
            self.loader.recv()
        print('shutting down loader')
        self.loader.send(['quit',0])
        if self.server is not None:
            print('closing server connection')
            self.server.send(['quit',0])
