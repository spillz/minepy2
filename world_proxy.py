# standard library imports
import math
import itertools
import time
import numpy
import threading
import heapq
import logutil
from collections import deque
import queue
import concurrent.futures

# pyglet imports
import pyglet
image = pyglet.image
from pyglet.graphics import TextureGroup
from pyglet.math import Mat4
import pyglet.gl as gl


class _MeshJobResult(object):
    __slots__ = ("pos", "gen", "priority", "start_time", "force_no_light", "_result", "_exc")

    def __init__(self, pos, gen, priority, start_time, force_no_light):
        self.pos = pos
        self.gen = gen
        self.priority = priority
        self.start_time = start_time
        self.force_no_light = force_no_light
        self._result = None
        self._exc = None

    def set_result(self, value):
        self._result = value

    def set_exception(self, exc):
        self._exc = exc

    def result(self):
        if self._exc is not None:
            raise self._exc
        return self._result


class TransparentWaterGroup(TextureGroup):
    """Texture group that disables depth writes so water stays see-through."""
    def set_state(self):
        super().set_state()
        gl.glDepthMask(gl.GL_FALSE)

    def unset_state(self):
        gl.glDepthMask(gl.GL_TRUE)
        super().unset_state()

# local imports
import world_loader
import server_connection
import config
from config import SECTOR_SIZE, SECTOR_HEIGHT, LOADED_SECTORS
from util import normalize, sectorize, FACES, cube_v, cube_v2, compute_vertex_ao
from blocks import (
    BLOCK_VERTICES,
    BLOCK_COLORS,
    BLOCK_NORMALS,
    BLOCK_TEXTURES_FLIPPED,
    BLOCK_ID,
    BLOCK_SOLID,
    BLOCK_OCCLUDES,
    BLOCK_OCCLUDES_SAME,
    BLOCK_RENDER_ALL,
    BLOCK_GLOW,
    TEXTURE_PATH,
    BLOCK_LIGHT_LEVELS,
    DOOR_LOWER_IDS,
    DOOR_UPPER_IDS,
    BLOCK_COLLIDES,
    BLOCK_COLLISION_MIN,
    BLOCK_COLLISION_MAX,
    BLOCK_RENDER_OFFSET,
)
import mapgen
import numpy

WATER = BLOCK_ID['Water']
#import logging
#logging.basicConfig(level = logging.INFO)
#def world_log(msg, *args):
#    logging.log(logging.INFO, 'WORLD: '+msg, *args)

class SectorProxy(object):
    def __init__(self, position, batch_solid, batch_water, group, water_group, model, shown=True):
        self.position = position[0],0,position[2]
        self.bposition = position[0]-1,0,position[2]-1 #block relative position (the sector is overgenerated by one block along each x,z edge)
        self.group = group
        self.water_group = water_group
        self.model = model
        # A Batch is a collection of vertex lists for batched rendering.
        self.batch = batch_solid
        self.batch_water = batch_water
        self.blocks = numpy.zeros((SECTOR_SIZE+2,SECTOR_HEIGHT,SECTOR_SIZE+2),dtype='u2')
        self.light = None  # full (padded) light grid from loader
        self.light_iters_done = 0
        self.light_invalidated = False
        self.shown = shown
        # Mapping from position to a pyglet `VertextList` for all shown blocks.
        self.vt = []
        self.vt_water = []
        self.pending_vt = []
        self.pending_vt_water = []
        self.vt_data = None
        self.vt_upload_prepared = False
        self.vt_clear_pending = False
        self.vt_upload_solid = 0
        self.vt_upload_water = 0
        self.vt_solid_quads = 0
        self.vt_water_quads = 0
        self._last_draw_detail_frame = -1
        self.force_full_upload = False
        self.invalidate_vt = False
        self.mesh_built = False
        self.needs_seam_refresh = False
        self.mesh_job_pending = False
        self.mesh_job_dirty = False
        self.mesh_job_priority = False
        self.mesh_gen = 0
        self.pending_batch = None
        self.pending_batch_water = None
        self.patch_vt = []
        self.edit_token = 0
        self.edit_inflight = False

    def draw(self, draw_invalid = True, allow_upload = True):
        if self.batch is None or self.batch_water is None:
            self.batch, self.batch_water = self.model.get_batches()
        if allow_upload and draw_invalid and self.invalidate_vt:
            self.check_show()
            self.invalidate_vt = False
            draw_invalid = False
        self.batch.draw()
        return draw_invalid

    def draw_water(self):
        """Draw only the water batch for this sector."""
        self.batch_water.draw()

    def __getitem__(self, position):
        pos = position - numpy.array(self.bposition)
        if len(pos.shape)>1:
            pos = pos.T
            return self.blocks[pos[0],pos[1],pos[2]]
        return self.blocks[pos[0],pos[1],pos[2]]

    def invalidate(self):
        self.invalidate_vt = True

    def _clear_vt_lists(self, reset_upload_state=True):
        for vt in self.vt:
            vt.delete()
        for vt in self.vt_water:
            vt.delete()
        self.vt = []
        self.vt_water = []
        self.vt_clear_pending = False
        if reset_upload_state:
            self.vt_upload_prepared = False
            self.vt_upload_solid = 0
            self.vt_upload_water = 0
            self.vt_solid_quads = 0
            self.vt_water_quads = 0

    def _clear_pending_vt(self, recycle_batches=True):
        for vt in self.pending_vt:
            vt.delete()
        for vt in self.pending_vt_water:
            vt.delete()
        self.pending_vt = []
        self.pending_vt_water = []
        if recycle_batches and self.pending_batch is not None:
            self.model.unused_batches.append((self.pending_batch, self.pending_batch_water))
        self.pending_batch = None
        self.pending_batch_water = None

    def _vt_quad_count(self, vt_data, key):
        if vt_data is None:
            return 0
        entry = vt_data if not isinstance(vt_data, dict) else vt_data.get(key)
        if not entry or entry[0] <= 0:
            return 0
        return int(entry[0] // 4)

    def _prepare_upload_state(self, vt_data):
        self.vt_upload_prepared = True
        self.vt_upload_solid = 0
        self.vt_upload_water = 0
        self.vt_solid_quads = self._vt_quad_count(vt_data, 'solid')
        self.vt_water_quads = self._vt_quad_count(vt_data, 'water')

    def check_show(self,add_to_batch = True):
        if add_to_batch and self.vt_data is not None:
            use_pending = self.vt_clear_pending and (self.vt or self.vt_water)
            if use_pending and self.pending_vt and not self.vt_upload_prepared:
                # Discard partially built pending geometry for a newer mesh.
                self._clear_pending_vt()
            if use_pending and self.pending_batch is None:
                self.pending_batch, self.pending_batch_water = self.model.get_batches()
            if not self.vt_upload_prepared:
                self._prepare_upload_state(self.vt_data)

            def _build_list_chunk(vt_tuple, group, batch, start_quad, max_quads):
                if not vt_tuple or vt_tuple[0] <= 0:
                    return None, 0, 0
                (count, v, t, n, c) = vt_tuple
                quad_total = int(count // 4)
                if start_quad >= quad_total:
                    return None, 0, quad_total
                end_quad = min(quad_total, start_quad + max_quads)
                v_arr = numpy.asarray(v, dtype='f4')
                t_arr = numpy.asarray(t, dtype='f4')
                n_arr = numpy.asarray(n, dtype='f4')
                channels = int(len(c) / (quad_total * 4)) if quad_total else 4
                c_arr = numpy.asarray(c, dtype='f4')
                v_slice = v_arr[start_quad * 12:end_quad * 12].reshape(-1, 4, 3)
                t_slice = t_arr[start_quad * 8:end_quad * 8].reshape(-1, 4, 2)
                n_slice = n_arr[start_quad * 12:end_quad * 12].reshape(-1, 4, 3)
                c_slice = c_arr[start_quad * 4 * channels:end_quad * 4 * channels].reshape(-1, 4, channels)
                order = [0, 1, 2, 0, 2, 3]
                tri_verts = v_slice[:, order, :].reshape(-1, 3)
                tri_tex = t_slice[:, order, :].reshape(-1, 2)
                tri_norm = n_slice[:, order, :].reshape(-1, 3)
                tri_col = c_slice[:, order, :].reshape(-1, channels)
                tri_count = len(tri_verts)
                vt = self.model.program.vertex_list(
                    tri_count,
                    gl.GL_TRIANGLES,
                    batch=batch,
                    group=group,
                    position=('f', tri_verts.ravel().astype('f4')),
                    tex_coords=('f', tri_tex.ravel().astype('f4')),
                    normal=('f', tri_norm.ravel().astype('f4')),
                    color=('f', tri_col.ravel().astype('f4')),
                )
                return vt, end_quad - start_quad, quad_total

            tri_chunk = getattr(config, 'UPLOAD_TRIANGLE_CHUNK', None)
            max_quads = None
            if not self.force_full_upload and tri_chunk is not None and tri_chunk > 0:
                max_quads = max(1, int(tri_chunk // 2))

            t_upload_start = time.perf_counter()
            solid_data = self.model._get_vt_entry(self.vt_data, 'solid')
            water_data = self.model._get_vt_entry(self.vt_data, 'water')
            solid_list = self.pending_vt if use_pending else self.vt
            water_list = self.pending_vt_water if use_pending else self.vt_water
            solid_batch = self.pending_batch if use_pending else self.batch
            water_batch = self.pending_batch_water if use_pending else self.batch_water
            total_tris = 0
            if max_quads is None:
                vt, uploaded, _ = _build_list_chunk(
                    solid_data, self.group, solid_batch, self.vt_upload_solid, self.vt_solid_quads
                )
                if vt is not None:
                    solid_list.append(vt)
                self.vt_upload_solid += uploaded
                total_tris += uploaded * 2
                vt, uploaded, _ = _build_list_chunk(
                    water_data, self.water_group, water_batch, self.vt_upload_water, self.vt_water_quads
                )
                if vt is not None:
                    water_list.append(vt)
                self.vt_upload_water += uploaded
                total_tris += uploaded * 2
            else:
                budget = max_quads
                if self.vt_upload_water < self.vt_water_quads:
                    vt, uploaded, _ = _build_list_chunk(
                        water_data, self.water_group, water_batch, self.vt_upload_water, budget
                    )
                    if vt is not None:
                        water_list.append(vt)
                    self.vt_upload_water += uploaded
                    total_tris += uploaded * 2
                    budget = max(0, budget - uploaded)
                if budget and self.vt_upload_solid < self.vt_solid_quads:
                    vt, uploaded, _ = _build_list_chunk(
                        solid_data, self.group, solid_batch, self.vt_upload_solid, budget
                    )
                    if vt is not None:
                        solid_list.append(vt)
                    self.vt_upload_solid += uploaded
                    total_tris += uploaded * 2

            elapsed = (time.perf_counter() - t_upload_start) * 1000.0
            if total_tris:
                self.model._mesh_log(
                    f"upload sector={self.position} tris={total_tris} ms={elapsed:.1f}"
                )
            if getattr(config, 'MESH_LOG', False):
                try:
                    solid_entry = self.model._get_vt_entry(self.vt_data, 'solid')
                    water_entry = self.model._get_vt_entry(self.vt_data, 'water')
                    solid_quads = 0 if not solid_entry else int(solid_entry[0] // 4)
                    water_quads = 0 if not water_entry else int(water_entry[0] // 4)
                    vt_kind = 'dict' if isinstance(self.vt_data, dict) else 'tuple'
                    self.model._mesh_log(
                        f"upload_detail sector={self.position} vt={vt_kind} solid_quads={solid_quads} water_quads={water_quads}"
                    )
                except Exception:
                    pass

            if self.vt_upload_solid >= self.vt_solid_quads and self.vt_upload_water >= self.vt_water_quads:
                if use_pending:
                    if self.pending_batch is not None and self.pending_batch_water is not None:
                        old_vt = self.vt
                        old_vt_water = self.vt_water
                        old_batch = self.batch
                        old_batch_water = self.batch_water
                        self.vt = self.pending_vt
                        self.vt_water = self.pending_vt_water
                        self.batch = self.pending_batch
                        self.batch_water = self.pending_batch_water
                        self.pending_vt = []
                        self.pending_vt_water = []
                        self.pending_batch = None
                        self.pending_batch_water = None
                        for vt in old_vt:
                            vt.delete()
                        for vt in old_vt_water:
                            vt.delete()
                        self.model.unused_batches.append((old_batch, old_batch_water))
                    else:
                        self._clear_pending_vt()
                # Clear any temporary patch geometry once full mesh is uploaded.
                for pv in self.patch_vt:
                    pv.delete()
                self.patch_vt.clear()
                self.vt_data = None
                self.vt_upload_prepared = False
                self.vt_clear_pending = False
                self.force_full_upload = False
                self.edit_inflight = False
                self.invalidate_vt = False
                self.mesh_built = True
        elif add_to_batch and self.vt_data is None and self.invalidate_vt:
            # Lazy rebuild when vt data was cleared for seam sync.
            self.invalidate_vt = False
            self.model._submit_mesh_job(self)
            return False


class ModelProxy(object):

    def __init__(self, program):

        # A TextureGroup manages an OpenGL texture.
        texture = image.load(TEXTURE_PATH).get_texture()
        self.program = program
        shader_group = pyglet.graphics.ShaderGroup(self.program)
        # Bind texture via TextureGroup under the shader group.
        self.group = TextureGroup(texture, parent=shader_group, order=0)
        # Water draws after opaque with depth writes disabled so the seafloor stays visible.
        self.water_group = TransparentWaterGroup(texture, parent=shader_group, order=1)
        self.unused_batches = []
        self.pending_uploads = deque()
        self.pending_upload_set = set()
        self.load_radius = getattr(config, 'LOAD_RADIUS', LOADED_SECTORS + 1)  # prefetch a wider ring
        self.keep_radius = getattr(config, 'KEEP_RADIUS', self.load_radius + 1)  # hysteresis before unloading
        self.pending_seam_rebuild = set()
        self.sector_edit_tokens = {}
        self.mesh_single_worker = getattr(config, 'MESH_SINGLE_WORKER', False)
        self.mesh_results = queue.SimpleQueue()
        self.mesh_interrupt = threading.Event()
        self.pending_priority_jobs = 0
        self.pending_mesh_resume = set()
        if self.mesh_single_worker:
            self.mesh_executor = None
            self.mesh_executor_hi = None
            self._mesh_worker_stop = threading.Event()
            self._mesh_job_cv = threading.Condition()
            self._mesh_job_queue = deque()
            self._mesh_worker_thread = threading.Thread(
                target=self._mesh_worker_loop,
                name="MeshWorker",
                daemon=True,
            )
            self._mesh_worker_thread.start()
        else:
            self.mesh_executor = concurrent.futures.ThreadPoolExecutor(
                max_workers=getattr(config, 'MESH_WORKERS', 2)
            )
            self.mesh_executor_hi = concurrent.futures.ThreadPoolExecutor(
                max_workers=getattr(config, 'MESH_EDIT_WORKERS', 1)
            )
        self.frame_id = 0
        self.frame_start = None
        self.mesh_budget_deadline = None
        self.player_sector = None
        self.player_pos = None
        self.player_look = None
        self._last_queue_log_frame = -1
        self._last_missing_log_frame = -1
        self.loader_messages = queue.SimpleQueue()
        self._loader_stop = threading.Event()
        self._loader_thread = None

        # The world is stored in sector chunks.
        self.sectors = {}
        self.update_sectors_pos = []
        self.update_ref_pos = None
        self._load_candidates_time = 0.0
        self._mesh_candidates = []
        self._mesh_candidates_time = 0.0
        self._mesh_candidates_ref = None

        self.loader_requests = []
        self.active_loader_request = [None, None]
        self.n_requests = 0
        self.n_responses = 0

        loader_server_pipe = None
        self.server = None
        if config.DEBUG_SINGLE_BLOCK:
            # Create a single sector with one visible block for debugging.
            batch_solid, batch_water = self.get_batches()
            s = SectorProxy((0,0,0), batch_solid, batch_water, self.group, self.water_group, self, shown=True)
            s.blocks[:] = 0
            cx, cy, cz = SECTOR_SIZE//2, SECTOR_HEIGHT//2, SECTOR_SIZE//2
            block_id = 1  # dirt
            s.blocks[cx+1, cy, cz+1] = block_id
            vt_data = self._build_block_vt(block_id, numpy.array([cx, cy, cz], dtype=numpy.float32))
            s.vt_data = vt_data
            s.check_show()
            self.sectors[s.position] = s
            self.loader = None
            logutil.log("WORLD", f"single block spawned at world coords {(cx, cy, cz)}", level="DEBUG")
        else:
            if config.SERVER_IP is not None:
                print ('Starting server on %s'%(config.SERVER_IP,))
                self.server = server_connection.start_server_connection(config.SERVER_IP)
                loader_server_pipe = self.server.loader_pipe
            print ('Starting sector loader')
            self.loader = world_loader.start_loader(loader_server_pipe)
            self._loader_thread = threading.Thread(
                target=self._loader_recv_loop,
                name="LoaderRecv",
                daemon=True,
            )
            self._loader_thread.start()

    def _mesh_worker_loop(self):
        while not self._mesh_worker_stop.is_set():
            with self._mesh_job_cv:
                while not self._mesh_job_queue and not self._mesh_worker_stop.is_set():
                    self._mesh_job_cv.wait()
                if self._mesh_worker_stop.is_set():
                    break
                job, blocks, light_copy, light_iters_done, pos, ao_strength, ao_enabled, ambient, interrupt_event, force_no_light = self._mesh_job_queue.popleft()
            try:
                vt_data = self._build_mesh_job(
                    blocks,
                    light_copy,
                    light_iters_done,
                    pos,
                    ao_strength,
                    ao_enabled,
                    ambient,
                    interrupt_event,
                    force_no_light,
                )
            except Exception as e:
                job.set_exception(e)
            else:
                job.set_result(vt_data)
            self.mesh_results.put(job)

    def _enqueue_mesh_job(
        self,
        job,
        blocks,
        light_copy,
        light_iters_done,
        pos,
        ao_strength,
        ao_enabled,
        ambient,
        interrupt_event,
        force_no_light,
        priority=False,
    ):
        with self._mesh_job_cv:
            if priority:
                self._mesh_job_queue.appendleft((
                    job,
                    blocks,
                    light_copy,
                    light_iters_done,
                    pos,
                    ao_strength,
                    ao_enabled,
                    ambient,
                    interrupt_event,
                    force_no_light,
                ))
            else:
                self._mesh_job_queue.append((
                    job,
                    blocks,
                    light_copy,
                    light_iters_done,
                    pos,
                    ao_strength,
                    ao_enabled,
                    ambient,
                    interrupt_event,
                    force_no_light,
                ))
            self._mesh_job_cv.notify()

    def _loader_recv_loop(self):
        """Continuously drain loader responses so the loader never blocks on send."""
        while not self._loader_stop.is_set():
            try:
                raw = self.loader.recv()
            except EOFError:
                self.loader_messages.put(('__eof__', None))
                return
            except Exception as e:
                self.loader_messages.put(('__error__', e))
                return
            self.loader_messages.put(raw)

    def _has_budget(self, frame_start, upload_budget):
        if frame_start is None or upload_budget is None:
            return True
        return (time.perf_counter() - frame_start) < upload_budget

    def _mesh_log(self, msg):
        if not getattr(config, 'MESH_LOG', False):
            return
        logutil.log("MESH", msg)

    def _maybe_log_queue_state(self):
        if not getattr(config, 'LOG_QUEUE_STATE', False):
            return
        if self.frame_id == self._last_queue_log_frame:
            return
        self._last_queue_log_frame = self.frame_id
        inflight = self.n_requests - self.n_responses
        pending_sector_reqs = sum(1 for r in self.loader_requests if r[0] == 'sector_blocks')
        pending_mesh = 0
        for sector in self.sectors.values():
            if sector.mesh_job_pending:
                continue
            if sector.vt_data is None:
                pending_mesh += 1
                continue
            if self._needs_light(sector) and self._lighting_ready(sector):
                pending_mesh += 1
        logutil.log(
            "QUEUE",
            f"inflight={inflight} loader_requests={len(self.loader_requests)} "
            f"pending_sector_reqs={pending_sector_reqs} update_queue={len(self.update_sectors_pos)} "
            f"pending_mesh={pending_mesh} pending_uploads={len(self.pending_uploads)}",
        )

    def _maybe_log_missing_sectors(self, center):
        if not getattr(config, 'LOG_MISSING_SECTORS', False):
            return
        every = getattr(config, 'LOG_MISSING_SECTORS_EVERY_N_FRAMES', 30)
        if self.frame_id - self._last_missing_log_frame < every:
            return
        self._last_missing_log_frame = self.frame_id
        missing = []
        for dx, dz in itertools.product((-1, 0, 1), repeat=2):
            pos = (center[0] + dx * SECTOR_SIZE, 0, center[2] + dz * SECTOR_SIZE)
            if pos not in self.sectors:
                missing.append(pos)
        logutil.log("QUEUE", f"missing_3x3={missing}")

    def _should_refresh_load_candidates(self, ref_sector):
        if self.update_ref_pos != ref_sector:
            return True
        refresh_ms = getattr(config, 'LOAD_CANDIDATE_REFRESH_MS', None)
        if refresh_ms is None:
            return False
        return (time.perf_counter() - self._load_candidates_time) >= (refresh_ms / 1000.0)

    def _refresh_load_candidates(self, ref_sector, player_pos, look_vec, frustum_circle=None):
        if not self._should_refresh_load_candidates(ref_sector):
            return False
        self.update_ref_pos = ref_sector
        self.update_sectors_pos = self._compute_load_candidates(
            ref_sector, player_pos, look_vec, frustum_circle
        )
        self._load_candidates_time = time.perf_counter()
        return True

    def _should_refresh_mesh_candidates(self, ref_sector):
        if self._mesh_candidates_ref != ref_sector:
            return True
        refresh_ms = getattr(config, 'MESH_CANDIDATE_REFRESH_MS', None)
        if refresh_ms is None:
            return False
        return (time.perf_counter() - self._mesh_candidates_time) >= (refresh_ms / 1000.0)

    def _refresh_mesh_candidates(self, ref_sector, player_pos, look_vec, frustum_circle=None):
        if not self._should_refresh_mesh_candidates(ref_sector):
            return False
        self._mesh_candidates_ref = ref_sector
        self._mesh_candidates = self._compute_mesh_candidates(
            ref_sector, player_pos, look_vec, frustum_circle
        )
        self._mesh_candidates_time = time.perf_counter()
        return True

    def _needs_light(self, sector):
        if sector.light_invalidated:
            return True
        if sector.light is None:
            return True
        return sector.light_iters_done < 64

    def _mesh_ready(self, sector):
        require_neighbors = getattr(config, 'MESH_READY_REQUIRE_NEIGHBORS', True)
        if not require_neighbors:
            return True
        require_diagonals = getattr(config, 'MESH_READY_REQUIRE_DIAGONALS', True)
        return self._neighbors_ready(sector, require_diagonals=require_diagonals)

    def _lighting_ready(self, sector):
        return self._neighbors_ready(sector, require_diagonals=True)

    def _has_mesh_backlog(self):
        """Return True when there is mesh work ready to run on loaded sectors."""
        for sector in self.sectors.values():
            if sector.mesh_job_pending:
                return True
            needs_mesh = (sector.vt_data is None and not sector.mesh_built)
            if needs_mesh:
                if self._mesh_ready(sector):
                    return True
                continue
            if self._needs_light(sector) and self._lighting_ready(sector):
                return True
        return False

    def _in_priority_neighborhood(self, sector_pos, radius=1):
        if self.player_sector is None:
            return False
        px, _, pz = self.player_sector
        return (abs(sector_pos[0] - px) <= SECTOR_SIZE * radius
                and abs(sector_pos[2] - pz) <= SECTOR_SIZE * radius)

    def process_pending_mesh_jobs(self, frustum_circle=None, allow_submit=True):
        """Submit mesh jobs using current sector state (unmeshed -> unlit)."""
        if not allow_submit:
            return
        if self.player_sector is None:
            return

        candidates = []
        for sector in self.sectors.values():
            if sector.mesh_job_pending:
                continue
            needs_mesh = (sector.vt_data is None and not sector.mesh_built)
            if needs_mesh:
                if not self._mesh_ready(sector):
                    continue
                reason = "unmeshed"
            else:
                if not (self._needs_light(sector) and self._lighting_ready(sector)):
                    continue
                reason = "unlit"
            prio = self._sector_priority(
                self.player_sector,
                sector.position,
                self.player_pos,
                self.player_look,
                frustum_circle,
            )
            candidates.append((prio, sector, reason))

        if not candidates:
            return

        candidates.sort(key=lambda item: item[0])
        _, sector, reason = candidates[0]
        is_priority = self._in_priority_neighborhood(sector.position)
        self._mesh_log(f"queue sector={sector.position} reason={reason}")
        self._submit_mesh_job(sector, priority=is_priority)

    def _get_vt_entry(self, vt_data, key=None):
        """Return a single vt tuple from a dict or bare tuple."""
        if vt_data is None:
            return None
        if isinstance(vt_data, dict):
            if key is None:
                return vt_data.get('solid') or vt_data.get('water')
            return vt_data.get(key)
        return vt_data

    def _triangles_in_vt(self, vt_data):
        """Return triangle count for a vt_data tuple (quads -> tris)."""
        if not vt_data:
            return 0

        def _tri_count(entry):
            if not entry:
                return 0
            quad_count = entry[0] / 4.0
            return int(quad_count * 2)

        if isinstance(vt_data, dict):
            return _tri_count(vt_data.get('solid')) + _tri_count(vt_data.get('water'))
        return _tri_count(vt_data)

    def _upload_chunk_quads(self):
        tri_chunk = getattr(config, 'UPLOAD_TRIANGLE_CHUNK', None)
        if tri_chunk is None or tri_chunk <= 0:
            return None
        return max(1, int(tri_chunk // 2))

    def _triangles_in_vt_chunk(self, sector):
        """Return triangle count for the next upload chunk for a sector."""
        if sector.vt_data is None:
            return 0
        if sector.force_full_upload:
            return self._triangles_in_vt(sector.vt_data)
        chunk_quads = self._upload_chunk_quads()
        if chunk_quads is None:
            return self._triangles_in_vt(sector.vt_data)
        if not sector.vt_upload_prepared:
            sector._prepare_upload_state(sector.vt_data)
        if sector.vt_upload_solid < sector.vt_solid_quads:
            remaining = sector.vt_solid_quads - sector.vt_upload_solid
        elif sector.vt_upload_water < sector.vt_water_quads:
            remaining = sector.vt_water_quads - sector.vt_upload_water
        else:
            return 0
        return min(chunk_quads, remaining) * 2

    @staticmethod
    def _build_mesh_job(blocks, light_full, light_iters_done, position, ao_strength, ao_enabled, ambient, interrupt_event=None, force_no_light=False):
        """Build vt_data for a sector snapshot; runs off the main thread."""
        max_iters = 64
        # Compute exposed faces and lighting (if provided).
        # Reuse _compute_exposed logic inline to avoid touching shared state.
        air = (BLOCK_OCCLUDES[blocks] == 0)
        solid = (blocks > 0) & (blocks != WATER)
        exposed_faces = numpy.zeros(blocks.shape + (6,), dtype=bool)
        neighbor = blocks[:,1:,:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:,:-1,:]))
        exposed_faces[:,:-1,:,0] = ~neighbor_occ
        neighbor = blocks[:,:-1,:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:,1:,:]))
        exposed_faces[:,1:,:,1] = ~neighbor_occ
        neighbor = blocks[:-1,:,:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[1:,:,:]))
        exposed_faces[1:,:,:,2] = ~neighbor_occ
        neighbor = blocks[1:,:,:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:-1,:,:]))
        exposed_faces[:-1,:,:,3] = ~neighbor_occ
        neighbor = blocks[:,:,1:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:,:,:-1]))
        exposed_faces[:,:,:-1,4] = ~neighbor_occ
        neighbor = blocks[:,:,:-1]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:,:,1:]))
        exposed_faces[:,:,1:,5] = ~neighbor_occ
        render_all = BLOCK_RENDER_ALL[blocks] != 0
        exposed_faces = (exposed_faces | render_all[..., None]) & solid[..., None]

        if force_no_light:
            light_full = numpy.zeros(blocks.shape, dtype=numpy.float32)
        elif light_full is None:
            light = numpy.zeros(blocks.shape, dtype=numpy.float32)
            decay = getattr(config, 'LIGHT_DECAY', 0.75)
            top_y = blocks.shape[1] - 1
            for x in range(blocks.shape[0]):
                for z in range(blocks.shape[2]):
                    for y in range(top_y, -1, -1):
                        if air[x, y, z]:
                            light[x, y, z] = 1.0
                        else:
                            break
            block_emitters = BLOCK_LIGHT_LEVELS or {}
            for bid, lvl in block_emitters.items():
                emitters = numpy.argwhere(blocks == bid)
                for ex, ey, ez in emitters:
                    light[ex, ey, ez] = max(light[ex, ey, ez], float(lvl))
            diag_decay = decay * math.sqrt(2.0)
            corner_decay = decay * math.sqrt(3.0)
            for i in range(light_iters_done, max_iters):
                neighbor_max = numpy.zeros_like(light)
                neighbor_max[:-1,:,:] = numpy.maximum(neighbor_max[:-1,:,:], light[1:,:,:] - decay)
                neighbor_max[1:,:,:]  = numpy.maximum(neighbor_max[1:,:,:],  light[:-1,:,:] - decay)
                neighbor_max[:,:-1,:] = numpy.maximum(neighbor_max[:,:-1,:], light[:,1:,:] - decay)
                neighbor_max[:,1:,:]  = numpy.maximum(neighbor_max[:,1:,:],  light[:,:-1,:] - decay)
                neighbor_max[:,:,:-1] = numpy.maximum(neighbor_max[:,:,:-1], light[:,:,1:] - decay)
                neighbor_max[:,:,1:]  = numpy.maximum(neighbor_max[:,:,1:],  light[:,:,:-1] - decay)
                neighbor_max[:-1,:-1,:] = numpy.maximum(neighbor_max[:-1,:-1,:], light[1:,1:,:] - diag_decay)
                neighbor_max[:-1,1:,:]  = numpy.maximum(neighbor_max[:-1,1:,:],  light[1:,:-1,:] - diag_decay)
                neighbor_max[1:,:-1,:]  = numpy.maximum(neighbor_max[1:,:-1,:],  light[:-1,1:,:] - diag_decay)
                neighbor_max[1:,1:,:]   = numpy.maximum(neighbor_max[1:,1:,:],   light[:-1,:-1,:] - diag_decay)
                neighbor_max[:-1,:,:-1] = numpy.maximum(neighbor_max[:-1,:,:-1], light[1:,:,1:] - diag_decay)
                neighbor_max[:-1,:,1:]  = numpy.maximum(neighbor_max[:-1,:,1:],  light[1:,:,:-1] - diag_decay)
                neighbor_max[1:,:,:-1]  = numpy.maximum(neighbor_max[1:,:,:-1],  light[:-1,:,1:] - diag_decay)
                neighbor_max[1:,:,1:]   = numpy.maximum(neighbor_max[1:,:,1:],   light[:-1,:,:-1] - diag_decay)
                neighbor_max[:,:-1,:-1] = numpy.maximum(neighbor_max[:,:-1,:-1], light[:,1:,1:] - diag_decay)
                neighbor_max[:,1:,:-1]  = numpy.maximum(neighbor_max[:,1:,:-1],  light[:,:-1,1:] - diag_decay)
                neighbor_max[:,:-1,1:]  = numpy.maximum(neighbor_max[:,:-1,1:],  light[:,1:,:-1] - diag_decay)
                neighbor_max[:,1:,1:]   = numpy.maximum(neighbor_max[:,1:,1:],   light[:,:-1,:-1] - diag_decay)
                neighbor_max[:-1,:-1,:-1] = numpy.maximum(neighbor_max[:-1,:-1,:-1], light[1:,1:,1:] - corner_decay)
                neighbor_max[:-1,:-1,1:]  = numpy.maximum(neighbor_max[:-1,:-1,1:],  light[1:,1:,:-1] - corner_decay)
                neighbor_max[:-1,1:,:-1]  = numpy.maximum(neighbor_max[:-1,1:,:-1],  light[1:,:-1,1:] - corner_decay)
                neighbor_max[:-1,1:,1:]   = numpy.maximum(neighbor_max[:-1,1:,1:],   light[1:,:-1,:-1] - corner_decay)
                neighbor_max[1:,:-1,:-1] = numpy.maximum(neighbor_max[1:,:-1,:-1], light[:-1,1:,1:] - corner_decay)
                neighbor_max[1:,:-1,1:]  = numpy.maximum(neighbor_max[1:,:-1,1:],  light[:-1,1:,:-1] - corner_decay)
                neighbor_max[1:,1:,:-1]  = numpy.maximum(neighbor_max[1:,1:,:-1],  light[:-1,:-1,1:] - corner_decay)
                neighbor_max[1:,1:,1:]   = numpy.maximum(neighbor_max[1:,1:,1:],   light[:-1,:-1,:-1] - corner_decay)
                new_light = numpy.where(air, numpy.maximum(light, neighbor_max), 0.0)
                if numpy.array_equal(new_light, light):
                    light_iters_done = i + 1
                    break
                light = new_light
                light_iters_done = i + 1
                if (interrupt_event is not None and interrupt_event.is_set()
                        and light_iters_done < max_iters):
                    return ('partial_light', light, light_iters_done)
            light_full = light
        elif light_iters_done < max_iters and not force_no_light:
            light = light_full
            decay = getattr(config, 'LIGHT_DECAY', 0.75)
            diag_decay = decay * math.sqrt(2.0)
            corner_decay = decay * math.sqrt(3.0)
            for i in range(light_iters_done, max_iters):
                neighbor_max = numpy.zeros_like(light)
                neighbor_max[:-1,:,:] = numpy.maximum(neighbor_max[:-1,:,:], light[1:,:,:] - decay)
                neighbor_max[1:,:,:]  = numpy.maximum(neighbor_max[1:,:,:],  light[:-1,:,:] - decay)
                neighbor_max[:,:-1,:] = numpy.maximum(neighbor_max[:,:-1,:], light[:,1:,:] - decay)
                neighbor_max[:,1:,:]  = numpy.maximum(neighbor_max[:,1:,:],  light[:,:-1,:] - decay)
                neighbor_max[:,:,:-1] = numpy.maximum(neighbor_max[:,:,:-1], light[:,:,1:] - decay)
                neighbor_max[:,:,1:]  = numpy.maximum(neighbor_max[:,:,1:],  light[:,:,:-1] - decay)
                neighbor_max[:-1,:-1,:] = numpy.maximum(neighbor_max[:-1,:-1,:], light[1:,1:,:] - diag_decay)
                neighbor_max[:-1,1:,:]  = numpy.maximum(neighbor_max[:-1,1:,:],  light[1:,:-1,:] - diag_decay)
                neighbor_max[1:,:-1,:]  = numpy.maximum(neighbor_max[1:,:-1,:],  light[:-1,1:,:] - diag_decay)
                neighbor_max[1:,1:,:]   = numpy.maximum(neighbor_max[1:,1:,:],   light[:-1,:-1,:] - diag_decay)
                neighbor_max[:-1,:,:-1] = numpy.maximum(neighbor_max[:-1,:,:-1], light[1:,:,1:] - diag_decay)
                neighbor_max[:-1,:,1:]  = numpy.maximum(neighbor_max[:-1,:,1:],  light[1:,:,:-1] - diag_decay)
                neighbor_max[1:,:,:-1]  = numpy.maximum(neighbor_max[1:,:,:-1],  light[:-1,:,1:] - diag_decay)
                neighbor_max[1:,:,1:]   = numpy.maximum(neighbor_max[1:,:,1:],   light[:-1,:,:-1] - diag_decay)
                neighbor_max[:,:-1,:-1] = numpy.maximum(neighbor_max[:,:-1,:-1], light[:,1:,1:] - diag_decay)
                neighbor_max[:,1:,:-1]  = numpy.maximum(neighbor_max[:,1:,:-1],  light[:,:-1,1:] - diag_decay)
                neighbor_max[:,:-1,1:]  = numpy.maximum(neighbor_max[:,:-1,1:],  light[:,1:,:-1] - diag_decay)
                neighbor_max[:,1:,1:]   = numpy.maximum(neighbor_max[:,1:,1:],   light[:,:-1,:-1] - diag_decay)
                neighbor_max[:-1,:-1,:-1] = numpy.maximum(neighbor_max[:-1,:-1,:-1], light[1:,1:,1:] - corner_decay)
                neighbor_max[:-1,:-1,1:]  = numpy.maximum(neighbor_max[:-1,:-1,1:],  light[1:,1:,:-1] - corner_decay)
                neighbor_max[:-1,1:,:-1]  = numpy.maximum(neighbor_max[:-1,1:,:-1],  light[1:,:-1,1:] - corner_decay)
                neighbor_max[:-1,1:,1:]   = numpy.maximum(neighbor_max[:-1,1:,1:],   light[1:,:-1,:-1] - corner_decay)
                neighbor_max[1:,:-1,:-1] = numpy.maximum(neighbor_max[1:,:-1,:-1], light[:-1,1:,1:] - corner_decay)
                neighbor_max[1:,:-1,1:]  = numpy.maximum(neighbor_max[1:,:-1,1:],  light[:-1,1:,:-1] - corner_decay)
                neighbor_max[1:,1:,:-1]  = numpy.maximum(neighbor_max[1:,1:,:-1],  light[:-1,:-1,1:] - corner_decay)
                neighbor_max[1:,1:,1:]   = numpy.maximum(neighbor_max[1:,1:,1:],   light[:-1,:-1,:-1] - corner_decay)
                new_light = numpy.where(air, numpy.maximum(light, neighbor_max), 0.0)
                if numpy.array_equal(new_light, light):
                    light_iters_done = i + 1
                    break
                light = new_light
                light_iters_done = i + 1
                if (interrupt_event is not None and interrupt_event.is_set()
                        and light_iters_done < max_iters):
                    return ('partial_light', light, light_iters_done)
            light_full = light

        if (not force_no_light and interrupt_event is not None
                and interrupt_event.is_set() and light_iters_done < max_iters):
            return ('partial_light', light_full, light_iters_done)

        exposed_light = numpy.zeros(blocks.shape+(6,),dtype=numpy.float32)
        exposed_light[:,:-1,:,0] = light_full[:,1:,:] # up
        exposed_light[:,1:,:,1] = light_full[:,:-1,:] # down
        exposed_light[1:,:,:,2] = light_full[:-1,:,:] # left
        exposed_light[:-1,:,:,3] = light_full[1:,:,:] # right
        exposed_light[:,:,:-1,4] = light_full[:,:,1:] # front
        exposed_light[:,:,1:,5] = light_full[:,:,:-1] # back

        if not force_no_light and interrupt_event is not None and interrupt_event.is_set():
            return ('partial_light', light_full, light_iters_done)

        exposed_faces = exposed_faces[1:-1,:,1:-1]
        exposed_light = exposed_light[1:-1,:,1:-1]

        sx, sy, sz, _ = exposed_faces.shape
        face_mask = exposed_faces.reshape(sx*sy*sz, 6)
        light_flat = exposed_light.reshape(sx*sy*sz, 6)
        block_mask = face_mask.any(axis=1)
        ao = None
        if ao_enabled and block_mask.any():
            ao_solid = (BLOCK_SOLID[blocks] != 0) & (BLOCK_RENDER_ALL[blocks] == 0)
            ao = compute_vertex_ao(
                ao_solid,
                (sx, sy, sz),
                ao_strength,
                block_mask=block_mask,
            )
        v = numpy.array([], dtype=numpy.float32)
        t = numpy.array([], dtype=numpy.float32)
        n = numpy.array([], dtype=numpy.float32)
        c = numpy.array([], dtype=numpy.float32)
        count = 0
        sector_grid = numpy.indices((SECTOR_SIZE, SECTOR_HEIGHT, SECTOR_SIZE)).transpose(1,2,3,0).reshape((SECTOR_SIZE*SECTOR_HEIGHT*SECTOR_SIZE,3))
        if block_mask.any():
            pos = sector_grid[block_mask] + numpy.array(position)
            face_mask = face_mask[block_mask]
            light_flat = light_flat[block_mask]
            b = blocks[1:-1,:,1:-1].reshape(sx*sy*sz)[block_mask]
            verts = (0.5*BLOCK_VERTICES[b].reshape(len(b),6,4,3)
                     + pos[:,None,None,:] + BLOCK_RENDER_OFFSET).astype(numpy.float32)
            tex = BLOCK_TEXTURES_FLIPPED[b][:,:6].reshape(len(b),6,4,2).astype(numpy.float32)
            normals = numpy.broadcast_to(BLOCK_NORMALS[None,:,None,:], (len(b),6,4,3)).astype(numpy.float32)
            colors_base = BLOCK_COLORS[b][:,:6].reshape(len(b),6,4,3).astype(numpy.float32)
            light = light_flat[:, :, None, None]  # (N,6,1,1)
            colors_lit = colors_base * (ambient + (1.0 - ambient) * light)
            if ao is not None:
                ao_flat = numpy.where(face_mask[..., None], ao, 1.0)
                colors_lit = colors_lit * ao_flat[..., None]
            # Glow acts as a minimum brightness floor after AO.
            if BLOCK_GLOW is not None:
                glow = BLOCK_GLOW[b][:, None, None, None]
                if numpy.any(glow > 0):
                    colors_lit = numpy.maximum(colors_lit, colors_base * glow)
            emissive = BLOCK_GLOW[b][:, None, None, None] * 255.0
            emissive = numpy.broadcast_to(emissive, colors_lit.shape[:-1] + (1,))
            colors_rgba = numpy.concatenate([colors_lit, emissive], axis=3)
            colors = numpy.clip(colors_rgba, 0, 255)
            v = verts[face_mask].reshape(-1,3).ravel()
            t = tex[face_mask].reshape(-1,2).ravel()
            n = normals[face_mask].reshape(-1,3).ravel()
            c = colors[face_mask].reshape(-1,4).ravel()
            count = len(v)//3
        water_blocks = (blocks == WATER)
        water_exposed = numpy.zeros(blocks.shape + (6,), dtype=bool)
        neighbor = blocks[:,1:,:]
        air = (neighbor != WATER) & (BLOCK_SOLID[neighbor] == 0)
        water_exposed[:,:-1,:,0] = water_blocks[:,:-1,:] & air
        neighbor = blocks[:,:-1,:]
        air = (neighbor != WATER) & (BLOCK_SOLID[neighbor] == 0)
        water_exposed[:,1:,:,1] = water_blocks[:,1:,:] & air
        neighbor = blocks[:-1,:,:]
        air = (neighbor != WATER) & (BLOCK_SOLID[neighbor] == 0)
        water_exposed[1:,:,:,2] = water_blocks[1:,:,:] & air
        neighbor = blocks[1:,:,:]
        air = (neighbor != WATER) & (BLOCK_SOLID[neighbor] == 0)
        water_exposed[:-1,:,:,3] = water_blocks[:-1,:,:] & air
        neighbor = blocks[:,:,1:]
        air = (neighbor != WATER) & (BLOCK_SOLID[neighbor] == 0)
        water_exposed[:,:,:-1,4] = water_blocks[:,:,:-1] & air
        neighbor = blocks[:,:,:-1]
        air = (neighbor != WATER) & (BLOCK_SOLID[neighbor] == 0)
        water_exposed[:,:,1:,5] = water_blocks[:,:,1:] & air

        water_exposed = water_exposed[1:-1,:,1:-1]
        w_face_mask = water_exposed.reshape(sx*sy*sz, 6)
        water_mask = w_face_mask.any(axis=1)
        if water_mask.any():
            pos_w = sector_grid[water_mask] + numpy.array(position)
            face_mask_w = w_face_mask[water_mask]
            b = numpy.full(len(pos_w), WATER, dtype=numpy.int32)
            verts = (0.5*BLOCK_VERTICES[b].reshape(len(b),6,4,3)
                     + pos_w[:,None,None,:] + BLOCK_RENDER_OFFSET).astype(numpy.float32)
            tex = BLOCK_TEXTURES_FLIPPED[b][:,:6].reshape(len(b),6,4,2).astype(numpy.float32)
            normals = numpy.broadcast_to(BLOCK_NORMALS[None,:,None,:], (len(b),6,4,3)).astype(numpy.float32)
            colors = BLOCK_COLORS[b][:,:6].reshape(len(b),6,4,3).astype(numpy.float32)

            face_verts = verts[face_mask_w].reshape(-1,4,3)
            face_tex = tex[face_mask_w].reshape(-1,4,2)
            face_norm = normals[face_mask_w].reshape(-1,4,3)
            face_col = colors[face_mask_w].reshape(-1,4,3)
            emissive_w = numpy.zeros(face_col.shape[:-1] + (1,), dtype=face_col.dtype)
            face_col = numpy.concatenate([face_col, emissive_w], axis=2)

            wv = face_verts.reshape(-1,3).ravel()
            wtcoords = face_tex.reshape(-1,2).ravel()
            wn = face_norm.reshape(-1,3).ravel()
            wc = face_col.reshape(-1,4).ravel()
            water_count = len(wv) // 3
            water_data = (water_count, wv, wtcoords, wn, wc)
        else:
            water_data = None
        solid_data = (count, v, t, n, c)
        vt_data = {'solid': solid_data, 'water': water_data}
        if not force_no_light and light_full is not None:
            return ('mesh', vt_data, light_full, light_iters_done)
        return vt_data

    def _queue_upload(self, sector, priority=False):
        """Queue a sector for upload/rebuild; avoid reshuffling if already queued."""
        if sector in self.pending_upload_set:
            return
        self.pending_upload_set.add(sector)
        if priority:
            self.pending_uploads.appendleft(sector)
        else:
            self.pending_uploads.append(sector)

    def _dequeue_upload(self, sector):
        """Remove a sector from the upload queue if present."""
        if sector in self.pending_upload_set:
            self.pending_upload_set.discard(sector)
            try:
                self.pending_uploads.remove(sector)
            except ValueError:
                pass

    def _submit_mesh_job(self, sector, priority=False, force_no_light=False):
        """Kick off an async mesh build for this sector."""
        if priority:
            sector.mesh_job_priority = True
            self.mesh_interrupt.set()
        if sector.mesh_job_pending:
            sector.mesh_job_dirty = True
            return
        if sector.vt_data is not None and not sector.invalidate_vt and not self._needs_light(sector):
            return
        if force_no_light and getattr(config, 'REUSE_LIGHTING_WHEN_AVAILABLE', True) and sector.light is not None:
            force_no_light = False
        sector.mesh_job_pending = True
        sector.mesh_job_dirty = False
        sector.mesh_gen += 1
        blocks = sector.blocks.copy()
        if sector.light_invalidated:
            light_copy = None
            light_iters_done = 0
        else:
            light_copy = sector.light.copy() if sector.light is not None else None
            light_iters_done = sector.light_iters_done if sector.light is not None else 0
        ao_strength = getattr(config, 'AO_STRENGTH', 0.0)
        ao_enabled = getattr(config, 'AO_ENABLED', True)
        ambient = getattr(config, 'AMBIENT_LIGHT', 0.0)
        gen = sector.mesh_gen
        pos = sector.position

        use_priority = sector.mesh_job_priority or priority
        sector.mesh_job_priority = False
        if self.mesh_single_worker:
            job = _MeshJobResult(pos, gen, use_priority, time.perf_counter(), force_no_light)
            self._enqueue_mesh_job(
                job,
                blocks,
                light_copy,
                light_iters_done,
                pos,
                ao_strength,
                ao_enabled,
                ambient,
                None if use_priority else self.mesh_interrupt,
                force_no_light,
                priority=use_priority,
            )
        else:
            def _done(fut):
                self.mesh_results.put(fut)
            executor = self.mesh_executor_hi if use_priority else self.mesh_executor
            future = executor.submit(
                self._build_mesh_job,
                blocks,
                light_copy,
                light_iters_done,
                pos,
                ao_strength,
                ao_enabled,
                ambient,
                None if use_priority else self.mesh_interrupt,
                force_no_light,
            )
            future.gen = gen
            future.pos = pos
            future.priority = use_priority
            future.start_time = time.perf_counter()
            future.force_no_light = force_no_light
            future.add_done_callback(_done)
        if use_priority:
            self.pending_priority_jobs += 1
        self._mesh_log(
            f"submit sector={pos} gen={gen} priority={use_priority} force_no_light={force_no_light}"
        )

    def _drain_mesh_results(self):
        """Consume finished mesh jobs and enqueue uploads if still valid."""
        while not self.mesh_results.empty():
            fut = self.mesh_results.get_nowait()
            try:
                vt_data = fut.result()
            except Exception as e:
                logutil.log("MESH", f"job failed {e}", level="ERROR")
                continue
            pos = getattr(fut, 'pos', None)
            gen = getattr(fut, 'gen', None)
            was_priority = getattr(fut, 'priority', False)
            start_time = getattr(fut, 'start_time', None)
            force_no_light = getattr(fut, 'force_no_light', False)
            if start_time is not None:
                elapsed_ms = (time.perf_counter() - start_time) * 1000.0
            else:
                elapsed_ms = None
            if was_priority:
                self.pending_priority_jobs = max(0, self.pending_priority_jobs - 1)
            if pos is None:
                continue
            sector = self.sectors.get(pos)
            if sector is None:
                continue
            sector.mesh_job_pending = False
            if isinstance(vt_data, tuple) and len(vt_data) == 3 and vt_data[0] == 'partial_light':
                _, light_full, iters_done = vt_data
                sector.light = light_full
                sector.light_iters_done = iters_done
                sector.light_invalidated = False
                sector.mesh_job_dirty = False
                self.pending_mesh_resume.add(sector)
                if elapsed_ms is not None:
                    self._mesh_log(
                        f"partial_light sector={pos} gen={gen} iters={iters_done} ms={elapsed_ms:.1f}"
                    )
                continue
            if isinstance(vt_data, tuple) and len(vt_data) == 4 and vt_data[0] == 'mesh':
                _, vt_data, light_full, iters_done = vt_data
                sector.light = light_full
                sector.light_iters_done = 64
                sector.light_invalidated = False
            if sector.mesh_job_dirty:
                sector.mesh_job_dirty = False
                self._submit_mesh_job(sector, priority=sector.mesh_job_priority)
                continue
            if gen is not None and sector.mesh_gen != gen:
                # stale result
                continue
            sector.vt_data = vt_data
            sector.vt_upload_prepared = False
            sector.vt_clear_pending = True
            sector.mesh_built = True
            sector.invalidate()
            if getattr(config, 'MESH_LOG', False):
                try:
                    water_blocks = (sector.blocks == WATER)
                    water_entry = self._get_vt_entry(vt_data, 'water')
                    water_quads = 0 if not water_entry else int(water_entry[0] // 4)
                    if water_blocks.any() and water_quads == 0:
                        above = sector.blocks[:, 1:, :] != WATER
                        surface = water_blocks[:, :-1, :] & above
                        surface_count = int(surface.sum())
                        self._mesh_log(
                            f"water_missing sector={pos} blocks={int(water_blocks.sum())} surface={surface_count}"
                        )
                except Exception:
                    pass
            self._sync_light_to_neighbors(sector)
            if sector.shown:
                self._queue_upload(sector, priority=sector.edit_inflight)
            if elapsed_ms is not None:
                self._mesh_log(
                    f"done sector={pos} gen={gen} priority={was_priority} force_no_light={force_no_light} ms={elapsed_ms:.1f}"
                )
        if self.pending_priority_jobs == 0 and self.mesh_interrupt.is_set():
            self.mesh_interrupt.clear()
            if self.pending_mesh_resume:
                for sector in list(self.pending_mesh_resume):
                    if sector in self.sectors.values():
                        self._submit_mesh_job(sector)
                    self.pending_mesh_resume.discard(sector)

    def _sync_light_to_neighbors(self, sector):
        if sector.light is None:
            return
        for dx, dz, n in self.neighbor_sectors(sector.position):
            if n.light is None:
                continue
            changed = False
            if dx == 1:
                src = sector.light[SECTOR_SIZE, :, :]
                dst = n.light[0, :, :]
            elif dx == -1:
                src = sector.light[1, :, :]
                dst = n.light[SECTOR_SIZE + 1, :, :]
            elif dz == 1:
                src = sector.light[:, :, SECTOR_SIZE]
                dst = n.light[:, :, 0]
            elif dz == -1:
                src = sector.light[:, :, 1]
                dst = n.light[:, :, SECTOR_SIZE + 1]
            else:
                continue
            if not numpy.array_equal(dst, src):
                dst[...] = src
                changed = True
            if changed:
                n.light_iters_done = 64
                n.vt_data = None
                n.mesh_built = False
                n.invalidate()
                if n.shown:
                    self._submit_mesh_job(n)

    def process_pending_uploads(self, frame_start=None, upload_budget=None, uploaded_tris=0, tri_budget=None):
        """Upload queued sector vertex data while budget remains."""
        while self.pending_uploads and self._has_budget(frame_start, upload_budget):
            s = self.pending_uploads.popleft()
            self.pending_upload_set.discard(s)
            if s.vt_data is not None:
                tri_count = self._triangles_in_vt_chunk(s)
                over_time = not self._has_budget(frame_start, upload_budget)
                over_tris = tri_budget is not None and (uploaded_tris + tri_count) > tri_budget
                if not s.force_full_upload and (over_time or over_tris):
                    # Not enough budget left; try next frame.
                    self._queue_upload(s)
                    break
                s.check_show(add_to_batch=True)
                uploaded_tris += tri_count
            elif s.invalidate_vt:
                s.check_show(add_to_batch=True)
                s.invalidate_vt = False
        return uploaded_tris

    def _compute_exposed(self, blocks):
        # Occlusion mask: general occluders + same-type occluders (e.g., leaves occlude leaves).
        air = (BLOCK_OCCLUDES[blocks] == 0)
        solid = (blocks > 0) & (blocks != WATER)
        exposed_faces = numpy.zeros(blocks.shape + (6,), dtype=bool)
        # up (+y)
        neighbor = blocks[:,1:,:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:,:-1,:]))
        exposed_faces[:,:-1,:,0] = ~neighbor_occ
        # down (-y)
        neighbor = blocks[:,:-1,:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:,1:,:]))
        exposed_faces[:,1:,:,1] = ~neighbor_occ
        # left (-x)
        neighbor = blocks[:-1,:,:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[1:,:,:]))
        exposed_faces[1:,:,:,2] = ~neighbor_occ
        # right (+x)
        neighbor = blocks[1:,:,:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:-1,:,:]))
        exposed_faces[:-1,:,:,3] = ~neighbor_occ
        # forward (+z)
        neighbor = blocks[:,:,1:]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:,:,:-1]))
        exposed_faces[:,:,:-1,4] = ~neighbor_occ
        # back (-z)
        neighbor = blocks[:,:,:-1]
        neighbor_occ = BLOCK_OCCLUDES[neighbor].astype(bool) | (BLOCK_OCCLUDES_SAME[neighbor].astype(bool) & (neighbor == blocks[:,:,1:]))
        exposed_faces[:,:,1:,5] = ~neighbor_occ

        render_all = BLOCK_RENDER_ALL[blocks] != 0
        exposed_faces = (exposed_faces | render_all[..., None]) & solid[..., None]

        # Recompute baked lighting locally (skylight + optional block emitters)
        light = numpy.zeros(blocks.shape, dtype=numpy.float32)
        decay = getattr(config, 'LIGHT_DECAY', 0.75)
        top_y = blocks.shape[1] - 1
        # Skylight pass: no decay straight down until blocked.
        for x in range(blocks.shape[0]):
            for z in range(blocks.shape[2]):
                for y in range(top_y, -1, -1):
                    if air[x, y, z]:
                        light[x, y, z] = 1.0
                    else:
                        break
        # Block light emitters
        block_emitters = BLOCK_LIGHT_LEVELS or {}
        for bid, lvl in block_emitters.items():
            emitters = numpy.argwhere(blocks == bid)
            for ex, ey, ez in emitters:
                light[ex, ey, ez] = max(light[ex, ey, ez], float(lvl))

        diag_decay = decay * math.sqrt(2.0)
        corner_decay = decay * math.sqrt(3.0)
        for _ in range(64):
            neighbor_max = numpy.zeros_like(light)
            # Axis neighbors
            neighbor_max[:-1,:,:] = numpy.maximum(neighbor_max[:-1,:,:], light[1:,:,:] - decay)   # +x
            neighbor_max[1:,:,:]  = numpy.maximum(neighbor_max[1:,:,:],  light[:-1,:,:] - decay)  # -x
            neighbor_max[:,:-1,:] = numpy.maximum(neighbor_max[:,:-1,:], light[:,1:,:] - decay)   # +y
            neighbor_max[:,1:,:]  = numpy.maximum(neighbor_max[:,1:,:],  light[:,:-1,:] - decay)  # -y
            neighbor_max[:,:,:-1] = numpy.maximum(neighbor_max[:,:,:-1], light[:,:,1:] - decay)   # +z
            neighbor_max[:,:,1:]  = numpy.maximum(neighbor_max[:,:,1:],  light[:,:,:-1] - decay)  # -z
            # Edge diagonals (sqrt(2) cost)
            neighbor_max[:-1,:-1,:] = numpy.maximum(neighbor_max[:-1,:-1,:], light[1:,1:,:] - diag_decay)
            neighbor_max[:-1,1:,:]  = numpy.maximum(neighbor_max[:-1,1:,:],  light[1:,:-1,:] - diag_decay)
            neighbor_max[1:,:-1,:]  = numpy.maximum(neighbor_max[1:,:-1,:],  light[:-1,1:,:] - diag_decay)
            neighbor_max[1:,1:,:]   = numpy.maximum(neighbor_max[1:,1:,:],   light[:-1,:-1,:] - diag_decay)

            neighbor_max[:-1,:,:-1] = numpy.maximum(neighbor_max[:-1,:,:-1], light[1:,:,1:] - diag_decay)
            neighbor_max[:-1,:,1:]  = numpy.maximum(neighbor_max[:-1,:,1:],  light[1:,:,:-1] - diag_decay)
            neighbor_max[1:,:,:-1]  = numpy.maximum(neighbor_max[1:,:,:-1],  light[:-1,:,1:] - diag_decay)
            neighbor_max[1:,:,1:]   = numpy.maximum(neighbor_max[1:,:,1:],   light[:-1,:,:-1] - diag_decay)

            neighbor_max[:,:-1,:-1] = numpy.maximum(neighbor_max[:,:-1,:-1], light[:,1:,1:] - diag_decay)
            neighbor_max[:,1:,:-1]  = numpy.maximum(neighbor_max[:,1:,:-1],  light[:,:-1,1:] - diag_decay)
            neighbor_max[:,:-1,1:]  = numpy.maximum(neighbor_max[:,:-1,1:],  light[:,1:,:-1] - diag_decay)
            neighbor_max[:,1:,1:]   = numpy.maximum(neighbor_max[:,1:,1:],   light[:,:-1,:-1] - diag_decay)
            # Corner diagonals (sqrt(3) cost)
            neighbor_max[:-1,:-1,:-1] = numpy.maximum(neighbor_max[:-1,:-1,:-1], light[1:,1:,1:] - corner_decay)
            neighbor_max[:-1,:-1,1:]  = numpy.maximum(neighbor_max[:-1,:-1,1:],  light[1:,1:,:-1] - corner_decay)
            neighbor_max[:-1,1:,:-1]  = numpy.maximum(neighbor_max[:-1,1:,:-1],  light[1:,:-1,1:] - corner_decay)
            neighbor_max[:-1,1:,1:]   = numpy.maximum(neighbor_max[:-1,1:,1:],   light[1:,:-1,:-1] - corner_decay)

            neighbor_max[1:,:-1,:-1] = numpy.maximum(neighbor_max[1:,:-1,:-1], light[:-1,1:,1:] - corner_decay)
            neighbor_max[1:,:-1,1:]  = numpy.maximum(neighbor_max[1:,:-1,1:],  light[:-1,1:,:-1] - corner_decay)
            neighbor_max[1:,1:,:-1]  = numpy.maximum(neighbor_max[1:,1:,:-1],  light[:-1,:-1,1:] - corner_decay)
            neighbor_max[1:,1:,1:]   = numpy.maximum(neighbor_max[1:,1:,1:],   light[:-1,:-1,:-1] - corner_decay)

            new_light = numpy.where(air, numpy.maximum(light, neighbor_max), 0.0)
            if numpy.array_equal(new_light, light):
                break
            light = new_light

        exposed_light = numpy.zeros(blocks.shape+(6,),dtype=numpy.float32)
        exposed_light[:,:-1,:,0] = light[:,1:,:] # up
        exposed_light[:,1:,:,1] = light[:,:-1,:] # down
        exposed_light[1:,:,:,2] = light[:-1,:,:] # left
        exposed_light[:-1,:,:,3] = light[1:,:,:] # right
        exposed_light[:,:,:-1,4] = light[:,:,1:] # front
        exposed_light[:,:,1:,5] = light[:,:,:-1] # back
        return exposed_faces, exposed_light, light

    def _recompute_vt(self, sector, force_no_light=False, reuse_light=True):
        ao_strength = getattr(config, 'AO_STRENGTH', 0.0)
        # Prefer loader-provided light field to avoid recomputing flood-fill on the client.
        if sector.light is not None and reuse_light:
            blocks = sector.blocks
            light_full = sector.light
            solid = (blocks > 0) & (blocks != WATER)
            exposed_faces = numpy.zeros(blocks.shape + (6,), dtype=bool)
            def neighbor_occ_mask(cur_block, neighbor_block):
                solid_occ = BLOCK_SOLID[neighbor_block] != 0
                same_occ = (BLOCK_OCCLUDES_SAME[neighbor_block] != 0) & (neighbor_block == cur_block)
                return solid_occ | same_occ
            neighbor = blocks[:,1:,:]
            exposed_faces[:,:-1,:,0] = ~neighbor_occ_mask(blocks[:,:-1,:], neighbor)
            neighbor = blocks[:,:-1,:]
            exposed_faces[:,1:,:,1] = ~neighbor_occ_mask(blocks[:,1:,:], neighbor)
            neighbor = blocks[:-1,:,:]
            exposed_faces[1:,:,:,2] = ~neighbor_occ_mask(blocks[1:,:,:], neighbor)
            neighbor = blocks[1:,:,:]
            exposed_faces[:-1,:,:,3] = ~neighbor_occ_mask(blocks[:-1,:,:], neighbor)
            neighbor = blocks[:,:,1:]
            exposed_faces[:,:,:-1,4] = ~neighbor_occ_mask(blocks[:,:,:-1], neighbor)
            neighbor = blocks[:,:,:-1]
            exposed_faces[:,:,1:,5] = ~neighbor_occ_mask(blocks[:,:,1:], neighbor)
            render_all = BLOCK_RENDER_ALL[blocks] != 0
            exposed_faces = (exposed_faces | render_all[..., None]) & solid[..., None]

            exposed_light = numpy.zeros(blocks.shape+(6,),dtype=numpy.float32)
            exposed_light[:,:-1,:,0] = light_full[:,1:,:] # up
            exposed_light[:,1:,:,1] = light_full[:,:-1,:] # down
            exposed_light[1:,:,:,2] = light_full[:-1,:,:] # left
            exposed_light[:-1,:,:,3] = light_full[1:,:,:] # right
            exposed_light[:,:,:-1,4] = light_full[:,:,1:] # front
            exposed_light[:,:,1:,5] = light_full[:,:,:-1] # back
        elif force_no_light:
            blocks = sector.blocks
            solid = (blocks > 0) & (blocks != WATER)
            exposed_faces = numpy.zeros(blocks.shape + (6,), dtype=bool)
            def neighbor_occ_mask(cur_block, neighbor_block):
                solid_occ = BLOCK_SOLID[neighbor_block] != 0
                same_occ = (BLOCK_OCCLUDES_SAME[neighbor_block] != 0) & (neighbor_block == cur_block)
                return solid_occ | same_occ
            neighbor = blocks[:,1:,:]
            exposed_faces[:,:-1,:,0] = ~neighbor_occ_mask(blocks[:,:-1,:], neighbor)
            neighbor = blocks[:,:-1,:]
            exposed_faces[:,1:,:,1] = ~neighbor_occ_mask(blocks[:,1:,:], neighbor)
            neighbor = blocks[:-1,:,:]
            exposed_faces[1:,:,:,2] = ~neighbor_occ_mask(blocks[1:,:,:], neighbor)
            neighbor = blocks[1:,:,:]
            exposed_faces[:-1,:,:,3] = ~neighbor_occ_mask(blocks[:-1,:,:], neighbor)
            neighbor = blocks[:,:,1:]
            exposed_faces[:,:,:-1,4] = ~neighbor_occ_mask(blocks[:,:,:-1], neighbor)
            neighbor = blocks[:,:,:-1]
            exposed_faces[:,:,1:,5] = ~neighbor_occ_mask(blocks[:,:,1:], neighbor)
            render_all = BLOCK_RENDER_ALL[blocks] != 0
            exposed_faces = (exposed_faces | render_all[..., None]) & solid[..., None]
            exposed_light = numpy.zeros(blocks.shape+(6,),dtype=numpy.float32)
        else:
            exposed_faces, exposed_light, light_full = self._compute_exposed(sector.blocks)
            sector.light = light_full
            sector.light_iters_done = 64
            sector.light_invalidated = False

        exposed_faces = exposed_faces[1:-1,:,1:-1]
        exposed_light = exposed_light[1:-1,:,1:-1]

        sx, sy, sz, _ = exposed_faces.shape
        face_mask = exposed_faces.reshape(sx*sy*sz, 6)
        light_flat = exposed_light.reshape(sx*sy*sz, 6)
        block_mask = face_mask.any(axis=1)
        ao = None
        if getattr(config, 'AO_ENABLED', True) and block_mask.any():
            ao_solid = (BLOCK_SOLID[sector.blocks] != 0) & (BLOCK_RENDER_ALL[sector.blocks] == 0)
            ao = compute_vertex_ao(
                ao_solid,
                (sx, sy, sz),
                ao_strength,
                block_mask=block_mask,
            )
        v = numpy.array([], dtype=numpy.float32)
        t = numpy.array([], dtype=numpy.float32)
        n = numpy.array([], dtype=numpy.float32)
        c = numpy.array([], dtype=numpy.float32)
        count = 0
        sector_grid = numpy.indices((SECTOR_SIZE, SECTOR_HEIGHT, SECTOR_SIZE)).transpose(1,2,3,0).reshape((SECTOR_SIZE*SECTOR_HEIGHT*SECTOR_SIZE,3))
        if block_mask.any():
            pos = sector_grid[block_mask] + numpy.array(sector.position)
            face_mask = face_mask[block_mask]
            light_flat = light_flat[block_mask]
            b = sector.blocks[1:-1,:,1:-1].reshape(sx*sy*sz)[block_mask]
            verts = (0.5*BLOCK_VERTICES[b].reshape(len(b),6,4,3)
                     + pos[:,None,None,:] + BLOCK_RENDER_OFFSET).astype(numpy.float32)
            tex = BLOCK_TEXTURES_FLIPPED[b][:,:6].reshape(len(b),6,4,2).astype(numpy.float32)
            normals = numpy.broadcast_to(BLOCK_NORMALS[None,:,None,:], (len(b),6,4,3)).astype(numpy.float32)
            colors_base = BLOCK_COLORS[b][:,:6].reshape(len(b),6,4,3).astype(numpy.float32)
            ambient = getattr(config, 'AMBIENT_LIGHT', 0.0)
            light = light_flat[:, :, None, None]  # (N,6,1,1)
            colors_lit = colors_base * (ambient + (1.0 - ambient) * light)
            if ao is not None:
                ao_flat = numpy.where(face_mask[..., None], ao, 1.0)
                colors_lit = colors_lit * ao_flat[..., None]
            if BLOCK_GLOW is not None:
                glow = BLOCK_GLOW[b][:, None, None, None]
                if numpy.any(glow > 0):
                    colors_lit = numpy.maximum(colors_lit, colors_base * glow)
            emissive = BLOCK_GLOW[b][:, None, None, None] * 255.0
            emissive = numpy.broadcast_to(emissive, colors_lit.shape[:-1] + (1,))
            colors_rgba = numpy.concatenate([colors_lit, emissive], axis=3)
            colors = numpy.clip(colors_rgba, 0, 255)
            v = verts[face_mask].reshape(-1,3).ravel()
            t = tex[face_mask].reshape(-1,2).ravel()
            n = normals[face_mask].reshape(-1,3).ravel()
            c = colors[face_mask].reshape(-1,4).ravel()
            count = len(v)//3
        # Water geometry: exposed faces of water blocks, duplicated for visibility above/below.
        water_blocks = (sector.blocks == WATER)
        water_exposed = numpy.zeros(sector.blocks.shape + (6,), dtype=bool)
        neighbor = sector.blocks[:,1:,:]
        water_exposed[:,:-1,:,0] = water_blocks[:,:-1,:] & (neighbor != WATER)
        neighbor = sector.blocks[:,:-1,:]
        water_exposed[:,1:,:,1] = water_blocks[:,1:,:] & (neighbor != WATER)
        neighbor = sector.blocks[:-1,:,:]
        water_exposed[1:,:,:,2] = water_blocks[1:,:,:] & (neighbor != WATER)
        neighbor = sector.blocks[1:,:,:]
        water_exposed[:-1,:,:,3] = water_blocks[:-1,:,:] & (neighbor != WATER)
        neighbor = sector.blocks[:,:,1:]
        water_exposed[:,:,:-1,4] = water_blocks[:,:,:-1] & (neighbor != WATER)
        neighbor = sector.blocks[:,:,:-1]
        water_exposed[:,:,1:,5] = water_blocks[:,:,1:] & (neighbor != WATER)

        water_exposed = water_exposed[1:-1,:,1:-1]
        w_face_mask = water_exposed.reshape(sx*sy*sz, 6)
        water_mask = w_face_mask.any(axis=1)
        if water_mask.any():
            pos_w = sector_grid[water_mask] + numpy.array(sector.position)
            face_mask_w = w_face_mask[water_mask]
            b = numpy.full(len(pos_w), WATER, dtype=numpy.int32)
            verts = (0.5*BLOCK_VERTICES[b].reshape(len(b),6,4,3)
                     + pos_w[:,None,None,:] + BLOCK_RENDER_OFFSET).astype(numpy.float32)
            tex = BLOCK_TEXTURES_FLIPPED[b][:,:6].reshape(len(b),6,4,2).astype(numpy.float32)
            normals = numpy.broadcast_to(BLOCK_NORMALS[None,:,None,:], (len(b),6,4,3)).astype(numpy.float32)
            colors = BLOCK_COLORS[b][:,:6].reshape(len(b),6,4,3).astype(numpy.float32)

            face_verts = verts[face_mask_w].reshape(-1,4,3)
            face_tex = tex[face_mask_w].reshape(-1,4,2)
            face_norm = normals[face_mask_w].reshape(-1,4,3)
            face_col = colors[face_mask_w].reshape(-1,4,3)
            emissive_w = numpy.zeros(face_col.shape[:-1] + (1,), dtype=face_col.dtype)
            face_col = numpy.concatenate([face_col, emissive_w], axis=2)

            wv = face_verts.reshape(-1,3).ravel()
            wtcoords = face_tex.reshape(-1,2).ravel()
            wn = face_norm.reshape(-1,3).ravel()
            wc = face_col.reshape(-1,4).ravel()
            water_count = len(wv) // 3
            water_data = (water_count, wv, wtcoords, wn, wc)
        else:
            water_data = None
        solid_data = (count, v, t, n, c)
        sector.vt_data = {'solid': solid_data, 'water': water_data}
        sector.vt_clear_pending = True
        sector.invalidate()

    def _rebuild_sector_now(self, sector, priority=False):
        """Synchronously rebuild a sector mesh on the main thread."""
        t0 = time.perf_counter()
        if not self._mesh_ready(sector):
            sector.needs_seam_refresh = True
            return
        force_no_light = False
        if getattr(config, 'DEFER_LIGHTING_UNTIL_NEIGHBORS', False):
            require_diag = getattr(config, 'DEFER_LIGHTING_REQUIRE_DIAGONALS', False)
            if not self._neighbors_ready(sector, require_diag):
                force_no_light = True
        reuse_light = getattr(config, 'REUSE_LIGHTING_WHEN_AVAILABLE', True)
        if sector.light_invalidated:
            reuse_light = False
        self._recompute_vt(sector, force_no_light=force_no_light, reuse_light=reuse_light)
        sector.vt_upload_prepared = False
        sector.vt_clear_pending = True
        sector.force_full_upload = bool(priority)
        sector.mesh_built = True
        if sector.shown:
            if priority:
                # Preempt queued uploads to show edits immediately.
                self._dequeue_upload(sector)
                sector.check_show(add_to_batch=True)
            else:
                self._queue_upload(sector, priority=priority)
        elapsed_ms = (time.perf_counter() - t0) * 1000.0
        self._mesh_log(
            f"sync sector={sector.position} priority={priority} force_no_light={force_no_light} ms={elapsed_ms:.1f}"
        )

    def _sync_edges_and_rebuild(self, sector, sync=False, priority=False, invalidate_light=False):
        # Copy boundary columns between this sector and loaded neighbors, then queue rebuilds.
        require_diag = getattr(config, 'SEAM_REQUIRE_DIAGONALS', False)
        if not self._neighbors_ready(sector, require_diag):
            # Defer until neighbors are available.
            self.pending_seam_rebuild.add(sector.position)
            self._mesh_log(f"seam_defer sector={sector.position} reason=neighbors_missing")
            if sync:
                self._rebuild_sector_now(sector, priority=priority)
            elif sector.vt_data is None:
                sector.needs_seam_refresh = True
            return
        self.pending_seam_rebuild.discard(sector.position)
        neighbors = list(self.neighbor_sectors(sector.position))
        changed_self = False
        for dx, dz, n in neighbors:
            changed_neighbor = False
            if dx == 1:
                # neighbor to the east
                if not numpy.array_equal(n.blocks[0, :, :], sector.blocks[SECTOR_SIZE, :, :]):
                    n.blocks[0, :, :] = sector.blocks[SECTOR_SIZE, :, :]
                    changed_neighbor = True
                if not numpy.array_equal(sector.blocks[SECTOR_SIZE + 1, :, :], n.blocks[1, :, :]):
                    sector.blocks[SECTOR_SIZE + 1, :, :] = n.blocks[1, :, :]
                    changed_self = True
            elif dx == -1:
                if not numpy.array_equal(n.blocks[SECTOR_SIZE + 1, :, :], sector.blocks[1, :, :]):
                    n.blocks[SECTOR_SIZE + 1, :, :] = sector.blocks[1, :, :]
                    changed_neighbor = True
                if not numpy.array_equal(sector.blocks[0, :, :], n.blocks[SECTOR_SIZE, :, :]):
                    sector.blocks[0, :, :] = n.blocks[SECTOR_SIZE, :, :]
                    changed_self = True
            if dz == 1:
                # neighbor to the south (positive z)
                if not numpy.array_equal(n.blocks[:, :, 0], sector.blocks[:, :, SECTOR_SIZE]):
                    n.blocks[:, :, 0] = sector.blocks[:, :, SECTOR_SIZE]
                    changed_neighbor = True
                if not numpy.array_equal(sector.blocks[:, :, SECTOR_SIZE + 1], n.blocks[:, :, 1]):
                    sector.blocks[:, :, SECTOR_SIZE + 1] = n.blocks[:, :, 1]
                    changed_self = True
            elif dz == -1:
                if not numpy.array_equal(n.blocks[:, :, SECTOR_SIZE + 1], sector.blocks[:, :, 1]):
                    n.blocks[:, :, SECTOR_SIZE + 1] = sector.blocks[:, :, 1]
                    changed_neighbor = True
                if not numpy.array_equal(sector.blocks[:, :, 0], n.blocks[:, :, SECTOR_SIZE]):
                    sector.blocks[:, :, 0] = n.blocks[:, :, SECTOR_SIZE]
                    changed_self = True
            if changed_neighbor and invalidate_light:
                n.light_invalidated = True
            self._mesh_log(f"seam_invalidate sector={n.position} source={sector.position}")
            if sync:
                if changed_neighbor:
                    self._rebuild_sector_now(n, priority=priority)
            elif changed_neighbor:
                n.invalidate()
                if n.shown:
                    self._submit_mesh_job(n)
                else:
                    n.needs_seam_refresh = True
        # Sync diagonal corner padding to avoid gaps when diagonals differ.
        diag_offsets = [(-1, -1), (-1, 1), (1, -1), (1, 1)]
        for dx, dz in diag_offsets:
            dpos = (sector.position[0] + dx * SECTOR_SIZE, 0, sector.position[2] + dz * SECTOR_SIZE)
            d = self.sectors.get(dpos)
            if d is None:
                continue
            changed_diag = False
            sx = 0 if dx == -1 else SECTOR_SIZE + 1
            sz = 0 if dz == -1 else SECTOR_SIZE + 1
            dx_src = SECTOR_SIZE if dx == -1 else 1
            dz_src = SECTOR_SIZE if dz == -1 else 1
            if not numpy.array_equal(sector.blocks[sx, :, sz], d.blocks[dx_src, :, dz_src]):
                sector.blocks[sx, :, sz] = d.blocks[dx_src, :, dz_src]
                changed_self = True
            dx_dst = SECTOR_SIZE + 1 if dx == -1 else 0
            dz_dst = SECTOR_SIZE + 1 if dz == -1 else 0
            sx_src = 1 if dx == -1 else SECTOR_SIZE
            sz_src = 1 if dz == -1 else SECTOR_SIZE
            if not numpy.array_equal(d.blocks[dx_dst, :, dz_dst], sector.blocks[sx_src, :, sz_src]):
                d.blocks[dx_dst, :, dz_dst] = sector.blocks[sx_src, :, sz_src]
                changed_diag = True
            if changed_diag and invalidate_light:
                d.light_invalidated = True
            if changed_diag:
                self._mesh_log(f"seam_invalidate sector={d.position} source=diag")
                d.invalidate()
                if sync:
                    self._rebuild_sector_now(d, priority=priority)
                elif d.shown:
                    self._submit_mesh_job(d)
                else:
                    d.needs_seam_refresh = True
        if invalidate_light:
            sector.light_invalidated = True
        self._mesh_log(f"seam_invalidate sector={sector.position} source=self")
        if sync:
            self._rebuild_sector_now(sector, priority=priority)
        else:
            if changed_self:
                sector.invalidate()
            if sector.shown:
                # Self rebuild with normal priority to minimize reordering churn.
                self._submit_mesh_job(sector)
            else:
                sector.needs_seam_refresh = True
        sector.needs_seam_refresh = False

    def set_matrices(self, projection, view, camera_pos):
        # Convert pyglet Mat4 to column-major numpy arrays
        proj = numpy.array(list(projection), dtype='f4').reshape((4, 4), order='F')
        view_mat = numpy.array(list(view), dtype='f4').reshape((4, 4), order='F')

        # The view matrix from look_at already has the translation.
        # The shader also applies translation via u_camera_pos.
        # To avoid double-correction, we remove the translation from the view matrix
        # and rely on the shader's relative positioning.
        view_mat[3, :3] = 0.0
        
        # Shader expects flat (1D) arrays
        self.program['u_projection'] = proj.ravel(order='F')
        self.program['u_view'] = view_mat.ravel(order='F')
        self.program['u_camera_pos'] = tuple(camera_pos) # Pass eye position
        
        # Set model matrix to identity for world rendering
        self.program['u_model'] = Mat4()

    def get_batches(self):
        while self.unused_batches:
            batch = self.unused_batches.pop(0)
            if batch[0] is not None and batch[1] is not None:
                return batch
        return (pyglet.graphics.Batch(), pyglet.graphics.Batch())

    def release_sector(self, sector):
        # Drop any pending uploads for this sector before freeing GPU buffers.
        self.pending_upload_set.discard(sector)
        try:
            self.pending_uploads.remove(sector)
        except ValueError:
            pass
        self.pending_seam_rebuild.discard(sector.position)
        sector._clear_vt_lists()
        sector._clear_pending_vt()
        sector.vt_data = None
        sector.mesh_job_pending = False
        sector.mesh_job_dirty = False
        sector.patch_vt = []
        self.unused_batches.append((sector.batch, sector.batch_water))
        del self.sectors[sector.position]

    def __getitem__(self, position):
        """
        retrieves the block at the (x,y,z) coordinate tuple `position`
        """
        try:
            return self.sectors[sectorize(position)][position]
        except:
            return None

    def get_vertical_column(self, x, z):
        """
        Return the full column of blocks at integer (x,z) coordinates, or None
        if the corresponding sector is not loaded.
        """
        sx = sectorize((x, 0, z))
        sector = self.sectors.get(sx)
        if sector is None:
            return None
        ix = int(round(x)) - (sector.position[0] - 1)
        iz = int(round(z)) - (sector.position[2] - 1)
        if not (0 <= ix < config.SECTOR_SIZE + 2 and 0 <= iz < config.SECTOR_SIZE + 2):
            return None
        return sector.blocks[ix, :, iz]

    def find_surface_y(self, x, z):
        """
        Find the y-coordinate of the ground at the given (x, z) position.
        """
        column = self.get_vertical_column(x, z)
        if column is None or column.size == 0:
            return None
        non_air = column != 0
        if not non_air.any():
            return None
        y = int(numpy.nonzero(non_air)[0][-1])
        return float(y + 1)

    def add_block(self, position, block, notify_server = True, keep_patches=False, priority=False):
        spos = sectorize(position)
        if spos in self.sectors:
            s = self.sectors[spos]
            # Apply locally for instant feedback
            rel = numpy.array(position) - numpy.array(s.position) + numpy.array([1,0,1])
            try:
                s.blocks[rel[0], rel[1], rel[2]] = block
            except Exception:
                pass
            s.invalidate_vt = True
            s.light_invalidated = True
            on_edge = rel[0] in (1, SECTOR_SIZE) or rel[2] in (1, SECTOR_SIZE)
            if priority or on_edge:
                self._sync_edges_and_rebuild(s, sync=True, priority=True, invalidate_light=True)
            else:
                self._submit_mesh_job(s, priority=True)
            s.edit_inflight = True
            blocks = s.blocks
            sector_data = [(spos, blocks)]
            for np in [(1,0,0), (-1,0,0), (0,0,1), (0,0,-1)]:
                nspos = sectorize((position[0]+np[0],position[1]+np[1],position[2]+np[2]))
                if nspos != spos and nspos in self.sectors:
                    nblocks = self.sectors[nspos].blocks
                    sector_data.append((nspos, nblocks))
            s.edit_token += 1
            self.sector_edit_tokens[spos] = s.edit_token
            self.loader_requests.insert(0,['set_block', [notify_server, position, block, sector_data, s.edit_token]])
            # Immediate visual patch
            if getattr(config, 'USE_PATCH_MESH', False):
                if not keep_patches:
                    for pv in s.patch_vt:
                        pv.delete()
                    s.patch_vt = []
                if block != 0:
                    world_pos = numpy.array(position, dtype=float)
                    vt = self._build_block_vt(block, world_pos)
                    key = 'water' if block == WATER else 'solid'
                    tri_verts, tri_tex, tri_norm, tri_col = self._triangulate_vt(vt, key)
                    if len(tri_verts) > 0:
                        group = s.water_group if block == WATER else s.group
                        batch = s.batch_water if block == WATER else s.batch
                        patch = self.program.vertex_list(
                            len(tri_verts),
                            gl.GL_TRIANGLES,
                            batch=batch,
                            group=group,
                            position=('f', tri_verts.ravel().astype('f4')),
                            tex_coords=('f', tri_tex.ravel().astype('f4')),
                            normal=('f', tri_norm.ravel().astype('f4')),
                            color=('f', tri_col.ravel().astype('f4')),
                          )
                        s.patch_vt.append(patch)

    def add_blocks(self, updates, notify_server=True, priority=False):
        """Batch apply multiple block updates in one loader request."""
        if not updates:
            return
        sector_updates = {}
        edge_sectors = set()
        for position, block in updates:
            spos = sectorize(position)
            if spos not in self.sectors:
                continue
            s = self.sectors[spos]
            rel = numpy.array(position) - numpy.array(s.position) + numpy.array([1, 0, 1])
            try:
                s.blocks[rel[0], rel[1], rel[2]] = block
            except Exception:
                continue
            s.invalidate_vt = True
            s.light_invalidated = True
            on_edge = rel[0] in (1, SECTOR_SIZE) or rel[2] in (1, SECTOR_SIZE)
            if on_edge:
                edge_sectors.add(spos)
            s.edit_inflight = True
            sector_updates.setdefault(spos, s)
        if not sector_updates:
            return
        for spos, s in sector_updates.items():
            if priority or spos in edge_sectors:
                self._sync_edges_and_rebuild(s, sync=True, priority=True, invalidate_light=True)
            else:
                self._submit_mesh_job(s, priority=True)
        sector_data = [(spos, sector.blocks) for spos, sector in sector_updates.items()]
        token_map = {}
        for spos, sector in sector_updates.items():
            sector.edit_token += 1
            self.sector_edit_tokens[spos] = sector.edit_token
            token_map[spos] = sector.edit_token
        self.loader_requests.insert(0, ['set_blocks', [notify_server, updates, sector_data, token_map]])
        # Immediate visual patch geometry.
        if getattr(config, 'USE_PATCH_MESH', False):
            for position, block in updates:
                spos = sectorize(position)
                if spos not in self.sectors:
                    continue
                s = self.sectors[spos]
                world_pos = numpy.array(position, dtype=float)
                vt = self._build_block_vt(block, world_pos)
                key = 'water' if block == WATER else 'solid'
                tri_verts, tri_tex, tri_norm, tri_col = self._triangulate_vt(vt, key)
                if len(tri_verts) == 0:
                    continue
                group = s.water_group if block == WATER else s.group
                batch = s.batch_water if block == WATER else s.batch
                patch = self.program.vertex_list(
                    len(tri_verts),
                    gl.GL_TRIANGLES,
                    batch=batch,
                    group=group,
                    position=('f', tri_verts.ravel().astype('f4')),
                    tex_coords=('f', tri_tex.ravel().astype('f4')),
                    normal=('f', tri_norm.ravel().astype('f4')),
                    color=('f', tri_col.ravel().astype('f4')),
                )
                s.patch_vt.append(patch)

    def remove_block(self, position, notify_server = True, priority=False):
        pos = normalize(position)
        existing = self[pos]
        if existing == WATER:
            if not self._can_remove_water(pos):
                return
        if existing in DOOR_LOWER_IDS:
            upper_pos = (pos[0], pos[1] + 1, pos[2])
            if self[upper_pos] in DOOR_UPPER_IDS:
                self.add_block(upper_pos, 0, notify_server, priority=priority)
        elif existing in DOOR_UPPER_IDS:
            lower_pos = (pos[0], pos[1] - 1, pos[2])
            if self[lower_pos] in DOOR_LOWER_IDS:
                self.add_block(lower_pos, 0, notify_server, priority=priority)
        self.add_block(pos, 0, notify_server, priority=priority)
        # If we removed terrain below the waterline and there's adjacent water, flow in.
        if existing != WATER and pos[1] < self._water_level():
            if any(self[normalize((pos[0]+dx, pos[1]+dy, pos[2]+dz))] == WATER for dx, dy, dz in FACES):
                self.add_block(pos, WATER, notify_server, priority=priority)

    def _can_remove_water(self, pos):
        """Allow removal only if water pocket is smaller than 4 contiguous blocks."""
        seen = set()
        q = [pos]
        water_count = 0
        while q:
            cur = q.pop()
            if cur in seen:
                continue
            seen.add(cur)
            if self[cur] != WATER:
                continue
            water_count += 1
            if water_count >= 4:
                return False
            cx, cy, cz = cur
            for dx, dy, dz in FACES:
                npos = (cx + dx, cy + dy, cz + dz)
                if npos not in seen:
                    q.append(npos)
        return True

    def _water_level(self):
        return getattr(mapgen, 'GLOBAL_WATER_LEVEL', getattr(mapgen, 'WATER_LEVEL', 70))

    def draw(self, position, frustum_circle, frame_start=None, upload_budget=None, defer_uploads=False, draw_water=True):
        """Draw only sectors intersecting the current view frustum projection. Limit or defer GPU uploads to respect frame budget."""
        self.frame_start = frame_start if frame_start is not None else time.perf_counter()
        draw_invalid = True
        uploaded_tris = 0
        tri_budget = getattr(config, 'UPLOAD_TRIANGLE_BUDGET', None)
        # Default to opaque pass.
        self.program['u_water_pass'] = False
        # Keep alpha synced with config in case it changes.
        self.program['u_water_alpha'] = getattr(config, 'WATER_ALPHA', 0.8)

        def budget_ok():
            return self._has_budget(frame_start, upload_budget)

        for s in self.sectors.values():
            visible = self._sector_overlaps_frustum(s.position, frustum_circle)
            s.shown = visible
            if visible and s.needs_seam_refresh:
                s.needs_seam_refresh = False
                self._sync_edges_and_rebuild(s)
            if not visible:
                continue

            if getattr(config, 'MESH_LOG', False):
                if self.frame_id - s._last_draw_detail_frame >= 30:
                    s._last_draw_detail_frame = self.frame_id
                    solid_verts = sum(getattr(vt, 'count', 0) for vt in s.vt)
                    water_verts = sum(getattr(vt, 'count', 0) for vt in s.vt_water)
                    exp_solid = s.vt_solid_quads * 6
                    exp_water = s.vt_water_quads * 6
                    self._mesh_log(
                        f"draw_detail sector={s.position} shown={s.shown} "
                        f"vt_solid={len(s.vt)} vt_water={len(s.vt_water)} "
                        f"solid_verts={solid_verts}/{exp_solid} "
                        f"water_verts={water_verts}/{exp_water} "
                        f"upload_solid={s.vt_upload_solid}/{s.vt_solid_quads} "
                        f"upload_water={s.vt_upload_water}/{s.vt_water_quads}"
                    )

            uploaded = False
            # Try to upload fresh vt_data if allowed; otherwise queue it.
            if s.vt_data is not None:
                tri_count = self._triangles_in_vt_chunk(s)
                over_tris = tri_budget is not None and (uploaded_tris + tri_count) > tri_budget
                over_time = not budget_ok()
                if not defer_uploads and (s.force_full_upload or (not over_time and not over_tris)):
                    s.check_show(add_to_batch=True)
                    self.pending_upload_set.discard(s)
                    uploaded = True
                    uploaded_tris += tri_count
                else:
                    self._queue_upload(s)
            # Handle invalidated buffers (edge sync) within the budget or queue.
            elif draw_invalid and s.invalidate_vt:
                if not defer_uploads and budget_ok():
                    s.check_show(add_to_batch=True)
                    s.invalidate_vt = False
                    uploaded = True
                else:
                    self._queue_upload(s)

            if uploaded:
                draw_invalid = False
            # Draw existing batch; skip uploads here to honor the budget.
            draw_invalid = s.draw(draw_invalid, allow_upload=False)

        # Drain async mesh results before uploads.
        self._drain_mesh_results()
        # Drain pending uploads while budget remains (only when not deferring).
        if not defer_uploads:
            uploaded_tris = self.process_pending_uploads(frame_start, upload_budget, uploaded_tris, tri_budget)
        if draw_water:
            self.draw_water_pass()

    def draw_water_pass(self):
        """Draw transparent water after opaque passes so depth writes stay intact."""
        # Ensure block shading path is active for water.
        self.program['u_use_texture'] = True
        self.program['u_use_vertex_color'] = True
        # Reset model transform so water is rendered in world space.
        self.program['u_model'] = Mat4()
        # Keep alpha synced with config in case it changes.
        self.program['u_water_alpha'] = getattr(config, 'WATER_ALPHA', 0.8)
        self.program['u_water_pass'] = True
        gl.glEnable(gl.GL_BLEND)
        gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)
        cull_enabled = gl.glIsEnabled(gl.GL_CULL_FACE)
        if cull_enabled:
            gl.glDisable(gl.GL_CULL_FACE)
        gl.glDepthMask(gl.GL_FALSE)  # depth test stays on; just stop writing so opaque depth survives
        for s in self.sectors.values():
            if s.shown:
                s.draw_water()
        gl.glDepthMask(gl.GL_TRUE)
        if cull_enabled:
            gl.glEnable(gl.GL_CULL_FACE)
        self.program['u_water_pass'] = False

    def neighbor_sectors(self, pos):
        """
        return a tuple (dx, dz, sector) of currently loaded neighbors to the sector at pos
        """
        pos = sectorize(pos)
        for x in ((-1,0),(1,0),(0,-1),(0,1)):
            npos = (pos[0]+x[0]*SECTOR_SIZE,0,pos[2]+x[1]*SECTOR_SIZE)
            if npos in self.sectors:
                yield x[0],x[1],self.sectors[npos]

    def _sector_overlaps_frustum(self, sector_pos, frustum_circle):
        """Return True if the sector AABB intersects the 2D frustum circle."""
        if not frustum_circle:
            return True
        (center, rad) = frustum_circle
        cx, cz = center
        min_x = sector_pos[0] - 1
        max_x = sector_pos[0] + SECTOR_SIZE + 1
        min_z = sector_pos[2] - 1
        max_z = sector_pos[2] + SECTOR_SIZE + 1
        # Clamp circle center to sector bounds to find closest point
        nearest_x = min(max(cx, min_x), max_x)
        nearest_z = min(max(cz, min_z), max_z)
        dx = cx - nearest_x
        dz = cz - nearest_z
        return (dx * dx + dz * dz) <= (rad * rad)

    def _sector_priority(self, ref_sector, sector_pos, player_pos, look_vec, frustum_circle=None):
        """Priority is distance-first, then frustum membership and alignment."""
        dist = (sector_pos[0] - ref_sector[0]) ** 2 + (sector_pos[2] - ref_sector[2]) ** 2
        outside_frustum = (
            frustum_circle is not None
            and not self._sector_overlaps_frustum(sector_pos, frustum_circle)
        )
        align_key = 0.0
        if (frustum_circle is not None and player_pos is not None and look_vec is not None):
            dx = (sector_pos[0] + SECTOR_SIZE * 0.5) - player_pos[0]
            dz = (sector_pos[2] + SECTOR_SIZE * 0.5) - player_pos[2]
            dist_len = math.hypot(dx, dz)
            look_len = math.hypot(look_vec[0], look_vec[2])
            if dist_len > 1e-6 and look_len > 1e-6:
                dot = (dx / dist_len) * (look_vec[0] / look_len) + (dz / dist_len) * (look_vec[2] / look_len)
                align_key = -dot
        if outside_frustum:
            align_key = 1.0
        return (dist, 1 if outside_frustum else 0, align_key)

    def _compute_load_candidates(self, ref_sector, player_pos, look_vec, frustum_circle=None):
        candidates = []
        load_radius = max(self.load_radius, LOADED_SECTORS)
        G = range(-load_radius, load_radius + 1)
        for dx, dy, dz in itertools.product(G, (0,), G):
            pos = numpy.array([ref_sector[0], ref_sector[1], ref_sector[2]]) + numpy.array(
                [dx * SECTOR_SIZE, dy, dz * SECTOR_SIZE]
            )
            pos = sectorize(pos)
            if pos in self.sectors:
                continue
            prio = self._sector_priority(ref_sector, pos, player_pos, look_vec, frustum_circle)
            candidates.append((prio, pos))
        candidates.sort()
        return candidates

    def _compute_mesh_candidates(self, ref_sector, player_pos, look_vec, frustum_circle=None):
        candidates = []
        for sector in self.sectors.values():
            if sector.mesh_job_pending:
                continue
            if sector.vt_data is None:
                if not self._mesh_ready(sector):
                    continue
            else:
                if not (self._needs_light(sector) and self._lighting_ready(sector)):
                    continue
            prio = self._sector_priority(
                ref_sector,
                sector.position,
                player_pos,
                look_vec,
                frustum_circle,
            )
            candidates.append((prio, sector))
        candidates.sort(key=lambda item: item[0])
        return candidates

    def pick_frame_work(self, ref_sector, player_pos, look_vec, frustum_circle=None):
        if self.update_ref_pos != ref_sector or not self.update_sectors_pos:
            self._refresh_load_candidates(ref_sector, player_pos, look_vec, frustum_circle)
        self._refresh_mesh_candidates(ref_sector, player_pos, look_vec, frustum_circle)
        load_candidates = self.update_sectors_pos
        mesh_candidates = self._mesh_candidates
        any_mesh_pending = any(s.mesh_job_pending for s in self.sectors.values())
        missing_near = False
        for _, pos in load_candidates:
            if (abs(pos[0] - ref_sector[0]) <= SECTOR_SIZE
                    and abs(pos[2] - ref_sector[2]) <= SECTOR_SIZE):
                missing_near = True
                break
        if not load_candidates and not mesh_candidates:
            return "none"
        if load_candidates and not mesh_candidates:
            return "load"
        if mesh_candidates and not load_candidates:
            return "mesh"
        if self.pending_seam_rebuild and load_candidates:
            return "load"
        if missing_near:
            return "load"
        if any_mesh_pending and load_candidates:
            return "load"
        load_prio, _ = load_candidates[0]
        mesh_prio, _ = mesh_candidates[0]
        return "load" if load_prio <= mesh_prio else "mesh"

    def _neighbors_ready(self, sector, require_diagonals=False):
        """Return True if the cardinal (and optionally diagonal) neighbors are loaded."""
        x0, _, z0 = sector.position
        card = [
            (x0 + SECTOR_SIZE, 0, z0),
            (x0 - SECTOR_SIZE, 0, z0),
            (x0, 0, z0 + SECTOR_SIZE),
            (x0, 0, z0 - SECTOR_SIZE),
        ]
        for p in card:
            if p not in self.sectors:
                return False
        if not require_diagonals:
            return True
        diag = [
            (x0 + SECTOR_SIZE, 0, z0 + SECTOR_SIZE),
            (x0 + SECTOR_SIZE, 0, z0 - SECTOR_SIZE),
            (x0 - SECTOR_SIZE, 0, z0 + SECTOR_SIZE),
            (x0 - SECTOR_SIZE, 0, z0 - SECTOR_SIZE),
        ]
        return all(p in self.sectors for p in diag)

    def is_sector_ready(self, position, radius=1, require_diagonals=False):
        """Return True when the player's sector and neighbors within radius are loaded."""
        spos = sectorize(position)
        sector = self.sectors.get(spos)
        if sector is None:
            return False
        if radius <= 0:
            return True
        if radius <= 1:
            return self._neighbors_ready(sector, require_diagonals)
        x0, _, z0 = sector.position
        for dx in range(-radius, radius + 1):
            for dz in range(-radius, radius + 1):
                pos = (x0 + dx * SECTOR_SIZE, 0, z0 + dz * SECTOR_SIZE)
                if pos not in self.sectors:
                    return False
        return True

    def _process_pending_seams(self, max_count=None):
        """Try to rebuild any sectors that were waiting for neighbors."""
        if not self.pending_seam_rebuild:
            return
        require_diag = getattr(config, 'SEAM_REQUIRE_DIAGONALS', False)
        processed = 0
        # Iterate over a copy to allow removal during rebuild.
        for pos in list(self.pending_seam_rebuild):
            if max_count is not None and processed >= max_count:
                break
            s = self.sectors.get(pos)
            if s is None:
                self.pending_seam_rebuild.discard(pos)
                continue
            if not s.shown:
                s.needs_seam_refresh = True
                continue
            if self._neighbors_ready(s, require_diag):
                self._sync_edges_and_rebuild(s)
                processed += 1
        # Clean up fulfilled entries
        for pos in list(self.pending_seam_rebuild):
            s = self.sectors.get(pos)
            if s and not s.needs_seam_refresh and self._neighbors_ready(s, require_diag):
                self.pending_seam_rebuild.discard(pos)

    def update_sectors(self, old, new, player_pos=None, look_vec=None, frustum_circle=None, ipc_budget_ms=None, allow_send=True):
        """
        the observer has moved from sector old to new
        """
        deadline = None
        if ipc_budget_ms is not None:
            if ipc_budget_ms <= 0.0:
                deadline = 0.0
            else:
                deadline = time.perf_counter() + ipc_budget_ms / 1000.0

        def _ipc_ok():
            if deadline is None:
                return True
            if deadline == 0.0:
                return False
            return time.perf_counter() <= deadline

        new = sectorize(new)
        self.player_sector = new
        self.player_pos = player_pos
        self.player_look = look_vec
        self._maybe_log_queue_state()
        self._maybe_log_missing_sectors(new)
        inflight = self.n_requests - self.n_responses
        max_inflight = getattr(config, 'LOADER_MAX_INFLIGHT', 1)
        strict_inflight = getattr(config, 'LOADER_STRICT_INFLIGHT', False)
        # Always allow IPC while the current sector is missing to bootstrap terrain.
        if new not in self.sectors:
            deadline = None

        prev_ref = self.update_ref_pos

        # Process any queued loader messages without blocking.
        processed_msgs = 0
        while not self.loader_messages.empty():
            if processed_msgs > 0 and not _ipc_ok():
                break
            raw = self.loader_messages.get_nowait()
            if isinstance(raw, tuple) and raw[0] == '__eof__':
                logutil.log("CLIENT", "loader returned EOF", level="WARN")
                break
            if isinstance(raw, tuple) and raw[0] == '__error__':
                logutil.log("CLIENT", f"loader recv error {raw[1]}", level="WARN")
                break
            recv_start = time.perf_counter()
            # Allow either (msg, data) tuples or variable-length lists.
            msg, data = None, None
            if isinstance(raw, (list, tuple)) and len(raw) > 0:
                msg = raw[0]
                if len(raw) == 2:
                    data = raw[1]
                else:
                    data = raw[1:]
            else:
                logutil.log("CLIENT", f"recv unexpected payload {raw}", level="WARN")
            recv_ms = (time.perf_counter() - recv_start) * 1000.0
            logutil.log("CLIENT", f"received {msg} in {recv_ms:.1f}ms")
            if msg == 'sector_blocks':
                spos1, b1, v1, light1 = data
                self.n_responses += 1
                self.active_loader_request = [None, None]
                logutil.log("CLIENT", f"loader response ms={(time.time()-self.loader_time)*1000.0:.1f}")
                self._update_sector(spos1, b1, v1, light1)
            if msg == 'sector_blocks2':
                self.n_responses += 1
                self.active_loader_request = [None, None]
                logutil.log("CLIENT", f"loader response ms={(time.time()-self.loader_time)*1000.0:.1f}")
                # sector_blocks2 payload may be [sector_results, token] or just sector_results
                token = None
                sector_results = data
                if isinstance(data, (list, tuple)) and len(data) == 2:
                    sector_results, token = data
                for item in sector_results:
                    spos, b, v, light = item
                    if token is not None:
                        # Drop stale responses superseded by newer edits.
                        if isinstance(token, dict):
                            if self.sector_edit_tokens.get(spos, 0) != token.get(spos, 0):
                                continue
                        elif isinstance(token, int):
                            if self.sector_edit_tokens.get(spos, 0) != token:
                                continue
                    self._update_sector(spos, b, v, light)
            # After processing loader message, drain a limited number of pending seam rebuilds to avoid bursts.
            max_seams = getattr(config, 'MAX_SEAM_REBUILDS_PER_TICK', None)
            self._process_pending_seams(max_seams)
            processed_msgs += 1

        # If no loader messages arrived, still attempt deferred seam rebuilds.
        if processed_msgs == 0:
            max_seams = getattr(config, 'MAX_SEAM_REBUILDS_PER_TICK', None)
            self._process_pending_seams(max_seams)

        refreshed = self._refresh_load_candidates(new, player_pos, look_vec, frustum_circle)
        if prev_ref != new:
            keep_radius = max(self.keep_radius, max(self.load_radius, LOADED_SECTORS))
            for s in list(self.sectors):
                if (abs(new[0] - s[0]) > keep_radius * SECTOR_SIZE
                        or abs(new[2] - s[2]) > keep_radius * SECTOR_SIZE):
                    logutil.log("WORLD", f"dropping sector={s} loaded={len(self.sectors)}")
                    self.release_sector(self.sectors[s])

        missing_any = False
        for _, pos in self.update_sectors_pos:
            if pos not in self.sectors:
                missing_any = True
                break

        if not missing_any and inflight == 0 and not self.loader_requests and processed_msgs == 0:
            if _ipc_ok() and self.server and self.server.poll():
                try:
                    msg, data = self.server.recv()
                    if msg == 'connected':
                        self.player, self.players = data
                    if msg == 'player_set_block':
                        logutil.log("SERVER", f"player_set_block {data}")
                        pos, block = data
                        self.add_block(pos, block, False, priority=False)
                except EOFError:
                    logutil.log("SERVER", "server returned EOF", level="WARN")
            return

        requested = set()
        if self.active_loader_request[0] == 'sector_blocks':
            requested.add(self.active_loader_request[1])
        for req in self.loader_requests:
            if req[0] == 'sector_blocks':
                requested.add(req[1][0])

        if refreshed or not self.loader_requests:
            non_sector = [r for r in self.loader_requests if r[0] != 'sector_blocks']
            candidates = []
            for priority, pos in self.update_sectors_pos:
                if pos in requested or pos in self.sectors:
                    continue
                in_3x3 = (abs(pos[0] - new[0]) <= SECTOR_SIZE
                          and abs(pos[2] - new[2]) <= SECTOR_SIZE)
                candidates.append(((0 if in_3x3 else 1), priority, pos))
            candidates.sort()
            queue_limit = max_inflight if max_inflight > 0 else 1
            sector_reqs = []
            for _, _, pos in candidates[:queue_limit]:
                logutil.log("WORLD", f"queueing sector={pos}")
                sector_reqs.append(['sector_blocks', [pos]])
            self.loader_requests = non_sector + sector_reqs

        block_on_mesh = getattr(config, 'LOADER_BLOCK_ON_MESH_BACKLOG', False)
        if block_on_mesh and allow_send and self._has_mesh_backlog():
            allow_send = False

        if allow_send and len(self.loader_requests) > 0:
            if strict_inflight and inflight > 0:
                pass
            else:
                req_type = self.loader_requests[0][0]
                if req_type != 'sector_blocks' or inflight < max_inflight:
                    self.loader_time = time.time()
                    self.n_requests += 1
                    if req_type == 'sector_blocks':
                        self.active_loader_request = ['sector_blocks', self.loader_requests[0][1][0]]
                    logutil.log("CLIENT", f"sending request to loader {self.loader_requests[0][0]}")
                    self.loader.send(self.loader_requests.pop(0))

        if _ipc_ok() and self.server and self.server.poll():
            try:
                msg, data = self.server.recv()
                if msg == 'connected':
                    self.player, self.players = data
                if msg == 'player_set_block':
                    logutil.log("SERVER", f"player_set_block {data}")
                    pos, block = data
                    self.add_block(pos, block, False, priority=False)
            except EOFError:
                logutil.log("SERVER", "server returned EOF", level="WARN")

    def _build_block_vt(self, block_id, pos):
        verts = (0.5*BLOCK_VERTICES[block_id][:6].reshape(6,4,3)
                 + pos[None,None,:] + BLOCK_RENDER_OFFSET).astype(numpy.float32)
        tex = BLOCK_TEXTURES_FLIPPED[block_id][:6].reshape(6,4,2).astype(numpy.float32)
        normals = numpy.broadcast_to(BLOCK_NORMALS[:,None,:], (6,4,3)).astype(numpy.float32)
        colors_rgb = BLOCK_COLORS[block_id][:6].reshape(6,4,3).astype(numpy.float32)
        emissive = numpy.full((6,4,1), BLOCK_GLOW[block_id]*255.0, dtype=numpy.float32)
        colors = numpy.concatenate([colors_rgb, emissive], axis=2)
        face_mask = numpy.ones((6,4), dtype=bool)
        v = verts[face_mask].ravel().astype('f4')
        t = tex[face_mask].ravel().astype('f4')
        n = normals[face_mask].ravel().astype('f4')
        c = colors[face_mask].ravel().astype('f4')
        count = len(v)//3
        if config.DEBUG_SINGLE_BLOCK:
            logutil.log("DEBUG", f"block vertex sample {v[:18]} tex {t[:8]}")
        solid = (count, v, t, n, c)
        return {'solid': solid, 'water': None}

    def _triangulate_vt(self, vt_data, key=None):
        """Convert quad vt_data to triangle arrays."""
        vt_tuple = self._get_vt_entry(vt_data, key)
        if not vt_tuple or vt_tuple[0] <= 0:
            return (numpy.array([], dtype='f4').reshape(0, 3),
                    numpy.array([], dtype='f4').reshape(0, 2),
                    numpy.array([], dtype='f4').reshape(0, 3),
                    numpy.array([], dtype='f4').reshape(0, 3))
        count, v, t, n, c = vt_tuple
        quad_verts = numpy.array(v, dtype='f4').reshape(-1, 4, 3)
        quad_tex = numpy.array(t, dtype='f4').reshape(-1, 4, 2)
        quad_norm = numpy.array(n, dtype='f4').reshape(-1, 4, 3)
        channels = int(len(c) // len(quad_verts) // 4) if len(quad_verts) else 3
        quad_col = numpy.array(c, dtype='f4').reshape(-1, 4, channels)
        order = [0, 1, 2, 0, 2, 3]
        tri_verts = quad_verts[:, order, :].reshape(-1, 3)
        tri_tex = quad_tex[:, order, :].reshape(-1, 2)
        tri_norm = quad_norm[:, order, :].reshape(-1, 3)
        tri_col = quad_col[:, order, :].reshape(-1, channels)
        return tri_verts, tri_tex, tri_norm, tri_col

    def _update_sector(self, spos, b, v, light):
        if b is not None:
            if spos in self.sectors:
                logutil.log("WORLD", f"updating existing sector data {spos}")
                s = self.sectors[spos]
                s.blocks[:,:,:] = b
                s.light = light
                s.light_iters_done = 64 if light is not None else 0
                s.light_invalidated = False
                s.vt_data = v
                s.mesh_built = v is not None
                s.vt_upload_prepared = False
                s.vt_clear_pending = True
                self._sync_edges_and_rebuild(s)
            else:
                logutil.log("WORLD", f"setting new sector data {spos}")
                batch_solid, batch_water = self.get_batches()
                s = SectorProxy(spos, batch_solid, batch_water, self.group, self.water_group, self)
                s.blocks[:,:,:] = b
                s.light = light
                s.light_iters_done = 64 if light is not None else 0
                s.light_invalidated = False
                s.vt_data = v
                s.mesh_built = v is not None
                s.vt_upload_prepared = False
                s.vt_clear_pending = True
                self.sectors[sectorize(spos)] = s
                self._sync_edges_and_rebuild(s)
        # A new/updated sector may unblock pending seam rebuilds.
        max_seams = getattr(config, 'MAX_SEAM_REBUILDS_PER_TICK', None)
        self._process_pending_seams(max_seams)

    def hit_test(self, position, vector, max_distance=8):
        """ Line of sight search from current position. If a block is
        intersected it is returned, along with the block previously in the line
        of sight. If no block is found, return None, None.

        Parameters
        ----------
        position : tuple of len 3
            The (x, y, z) position to check visibility from.
        vector : tuple of len 3
            The line of sight vector.
        max_distance : int
            How many blocks away to search for a hit.

        """
        m = 8
        x, y, z = position
        dx, dy, dz = vector
        previous = None
        for _ in range(max_distance * m):
            key = normalize((x, y, z))
            if key != previous:
                b = self[key]
                # Treat water as transparent for interaction; keep searching for solid terrain.
                if b != 0 and b is not None and b != WATER:
                    return key, previous
            previous = key
            x, y, z = x + dx / m, y + dy / m, z + dz / m
        return None, None

    def measure_void_distance(self, position, vector, max_distance=64):
        """Return the number of solid blocks after the first hit until air along a ray.

        Starts from the current sight line, finds the first solid block, then steps
        block-by-block along the ray direction until the first air/void cell or until
        max_distance is exceeded. Returns None when no initial hit is found.
        """
        hit, _ = self.hit_test(position, vector, max_distance=max_distance)
        if not hit:
            return None

        hx, hy, hz = hit
        dx, dy, dz = vector
        length = math.sqrt(dx * dx + dy * dy + dz * dz)
        if length == 0:
            return None
        dirx, diry, dirz = dx / length, dy / length, dz / length

        # Start at center of hit block to avoid immediately re-hitting it.
        cellx, celly, cellz = hx, hy, hz
        px, py, pz = hx + 0.5, hy + 0.5, hz + 0.5
        step_x = 1 if dirx >= 0 else -1
        step_y = 1 if diry >= 0 else -1
        step_z = 1 if dirz >= 0 else -1

        invx = 1.0 / dirx if dirx != 0 else float("inf")
        invy = 1.0 / diry if diry != 0 else float("inf")
        invz = 1.0 / dirz if dirz != 0 else float("inf")

        t_max_x = ((cellx + (1 if step_x > 0 else 0)) - px) * invx if invx != float("inf") else float("inf")
        t_max_y = ((celly + (1 if step_y > 0 else 0)) - py) * invy if invy != float("inf") else float("inf")
        t_max_z = ((cellz + (1 if step_z > 0 else 0)) - pz) * invz if invz != float("inf") else float("inf")

        t_delta_x = abs(invx)
        t_delta_y = abs(invy)
        t_delta_z = abs(invz)

        traveled_blocks = 0
        t = 0.0
        max_steps = int(math.ceil(max_distance)) + 2

        for _ in range(max_steps):
            # advance to next voxel boundary
            if t_max_x < t_max_y:
                if t_max_x < t_max_z:
                    cellx += step_x
                    t = t_max_x
                    t_max_x += t_delta_x
                else:
                    cellz += step_z
                    t = t_max_z
                    t_max_z += t_delta_z
            else:
                if t_max_y < t_max_z:
                    celly += step_y
                    t = t_max_y
                    t_max_y += t_delta_y
                else:
                    cellz += step_z
                    t = t_max_z
                    t_max_z += t_delta_z

            if t > max_distance:
                break
            block = self[(cellx, celly, cellz)]
            if block == 0 or block is None:
                return traveled_blocks
            traveled_blocks += 1

        return traveled_blocks

    def nearest_mushroom_in_sector(self, sector_pos, player_pos=None):
        """Return nearest mushroom world coords inside a loaded sector, or None."""
        mush_id = BLOCK_ID.get('Mushroom')
        if mush_id is None:
            return None
        sector = self.sectors.get(sector_pos)
        if sector is None or sector.blocks is None:
            return None
        coords = numpy.argwhere(sector.blocks == mush_id)
        if coords.size == 0:
            return None
        if player_pos is None:
            player_pos = (sector_pos[0], 0, sector_pos[2])
        px, py, pz = player_pos
        best = None
        best_d2 = None
        for cx, cy, cz in coords:
            wx = sector_pos[0] + int(cx) - 1
            wy = int(cy)
            wz = sector_pos[2] + int(cz) - 1
            dx = wx - px
            dy = wy - py
            dz = wz - pz
            d2 = dx*dx + dy*dy + dz*dz
            if best is None or d2 < best_d2:
                best = (wx, wy, wz)
                best_d2 = d2
        return best

    def exposed(self, position):
        """ Returns False is given `position` is surrounded on all 6 sides by
        blocks, True otherwise.

        """
        x, y, z = position
        for dx, dy, dz in FACES:
            b = self[normalize((x + dx, y + dy, z + dz))]
            if not BLOCK_SOLID[b]:
                return True
        return False

    def collide(self, position, bounding_box, velocity=None, prev_position=None):
        """
        Checks to see if an entity at the given `position` with the given
        `bounding_box` is colliding with any blocks in the world.

        Axis-aligned resolution against block AABBs.

        Parameters
        ----------
        position : tuple of len 3
            The (x, y, z) position to check for collisions at.
        bounding_box : tuple of len 3
            The (width, height, depth) of the entity.

        Returns
        -------
        position : tuple of len 3
            The new position of the entity taking into account collisions.
        vertical_collision : bool
            True if the entity collided with the ground or ceiling.
        """
        width, height, depth = bounding_box
        prev = prev_position if prev_position is not None else position
        p = [position[0], position[1], position[2]]
        vertical_collision = False
        horizontal_collision = False

        def axis_bounds(pos):
            min_x = pos[0] - width / 2
            max_x = pos[0] + width / 2
            min_y = pos[1]
            max_y = pos[1] + height
            min_z = pos[2] - depth / 2
            max_z = pos[2] + depth / 2
            return min_x, max_x, min_y, max_y, min_z, max_z

        def block_range(min_v, max_v, centered):
            eps = 1e-6
            if centered:
                lo = int(math.floor(min_v - 0.5 + eps))
                hi = int(math.floor(max_v + 0.5 - eps))
            else:
                lo = int(math.floor(min_v + eps))
                hi = int(math.floor(max_v - eps))
            return range(lo, hi + 1)

        def resolve_axis(axis, base_pos):
            nonlocal vertical_collision, horizontal_collision
            delta = p[axis] - prev[axis]
            if abs(delta) < 1e-6:
                return

            pos = [base_pos[0], base_pos[1], base_pos[2]]
            pos[axis] = prev[axis] + delta
            min_x, max_x, min_y, max_y, min_z, max_z = axis_bounds(pos)
            min_bx = block_range(min_x, max_x, centered=True)
            min_by = block_range(min_y, max_y, centered=False)
            min_bz = block_range(min_z, max_z, centered=True)

            prev_min_x, prev_max_x, prev_min_y, prev_max_y, prev_min_z, prev_max_z = axis_bounds(prev)

            for bx in min_bx:
                for by in min_by:
                    for bz in min_bz:
                        block_id = self[normalize((bx, by, bz))]
                        if not block_id or not BLOCK_COLLIDES[block_id]:
                            continue
                        block_min_x = bx + BLOCK_COLLISION_MIN[block_id][0]
                        block_max_x = bx + BLOCK_COLLISION_MAX[block_id][0]
                        block_min_y = by + BLOCK_COLLISION_MIN[block_id][1]
                        block_max_y = by + BLOCK_COLLISION_MAX[block_id][1]
                        block_min_z = bz + BLOCK_COLLISION_MIN[block_id][2]
                        block_max_z = bz + BLOCK_COLLISION_MAX[block_id][2]

                        if axis == 0:
                            if max_y <= block_min_y or min_y >= block_max_y:
                                continue
                            if max_z <= block_min_z or min_z >= block_max_z:
                                continue
                            if max_x <= block_min_x or min_x >= block_max_x:
                                continue
                            if delta > 0:
                                pos[0] = block_min_x - width / 2
                            else:
                                pos[0] = block_max_x + width / 2
                            horizontal_collision = True
                            min_x, max_x, min_y, max_y, min_z, max_z = axis_bounds(pos)
                        elif axis == 2:
                            if max_y <= block_min_y or min_y >= block_max_y:
                                continue
                            if max_x <= block_min_x or min_x >= block_max_x:
                                continue
                            if max_z <= block_min_z or min_z >= block_max_z:
                                continue
                            if delta > 0:
                                pos[2] = block_min_z - depth / 2
                            else:
                                pos[2] = block_max_z + depth / 2
                            horizontal_collision = True
                            min_x, max_x, min_y, max_y, min_z, max_z = axis_bounds(pos)
                        else:
                            if max_x <= block_min_x or min_x >= block_max_x:
                                continue
                            if max_z <= block_min_z or min_z >= block_max_z:
                                continue
                            if delta < 0 and prev_min_y >= block_max_y and min_y < block_max_y:
                                pos[1] = block_max_y
                                vertical_collision = True
                            elif delta > 0 and prev_max_y <= block_min_y and max_y > block_min_y:
                                pos[1] = block_min_y - height
                            min_x, max_x, min_y, max_y, min_z, max_z = axis_bounds(pos)

            p[axis] = pos[axis]

        # Resolve X with Y/Z at previous position.
        resolve_axis(0, prev)
        # Resolve Z with X resolved, Y at previous position.
        resolve_axis(2, (p[0], prev[1], prev[2]))
        # Resolve Y with X/Z resolved.
        resolve_axis(1, (p[0], prev[1], p[2]))

        # Snap to ground when falling to prevent jitter below surface.
        if p[1] <= prev[1] + 1e-6 and not horizontal_collision:
            min_x, max_x, min_y, max_y, min_z, max_z = axis_bounds(p)
            eps = 1e-4
            snap_pad = 1e-4
            for bx in block_range(min_x, max_x, centered=True):
                for bz in block_range(min_z, max_z, centered=True):
                    by = int(math.floor(min_y - eps))
                    block_id = self[normalize((bx, by, bz))]
                    if not block_id or not BLOCK_COLLIDES[block_id]:
                        continue
                    block_max_y = by + BLOCK_COLLISION_MAX[block_id][1]
                    block_min_x = bx + BLOCK_COLLISION_MIN[block_id][0]
                    block_max_x = bx + BLOCK_COLLISION_MAX[block_id][0]
                    block_min_z = bz + BLOCK_COLLISION_MIN[block_id][2]
                    block_max_z = bz + BLOCK_COLLISION_MAX[block_id][2]
                    overlap_x = min(max_x, block_max_x) - max(min_x, block_min_x)
                    overlap_z = min(max_z, block_max_z) - max(min_z, block_min_z)
                    if overlap_x <= snap_pad or overlap_z <= snap_pad:
                        continue
                    if min_y >= block_max_y - eps and min_y <= block_max_y + eps:
                        p[1] = block_max_y
                        vertical_collision = True
                        break
                if vertical_collision:
                    break
        return tuple(p), vertical_collision

    def quit(self,kill_server=True):
        if self.n_requests > self.n_responses:
            logutil.log(
                "WORLD",
                f"draining loader responses inflight={self.n_requests - self.n_responses}",
            )
            try:
                while not self.loader_messages.empty():
                    self.loader_messages.get_nowait()
                    self.n_responses += 1
            except Exception as e:
                logutil.log("WORLD", f"drain loader error {e}", level="WARN")
        if getattr(self, 'mesh_single_worker', False):
            self._mesh_worker_stop.set()
            if hasattr(self, '_mesh_job_cv'):
                with self._mesh_job_cv:
                    self._mesh_job_cv.notify()
            if getattr(self, '_mesh_worker_thread', None) is not None:
                self._mesh_worker_thread.join(timeout=0.2)
        logutil.log("WORLD", "shutting down loader")
        self._loader_stop.set()
        self.loader.send(['quit',0])
        if self.server is not None:
            logutil.log("WORLD", "closing server connection")
            self.server.send(['quit',0])
