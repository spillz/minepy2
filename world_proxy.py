# standard library imports
import math
import itertools
import time
import numpy
from collections import deque
import multiprocessing.connection
import multiprocessing.sharedctypes
import multiprocessing
try:
    import cPickle as pickle
except ImportError:
    import pickle
import gc

#gc.set_debug(gc.DEBUG_LEAK)

# pyglet imports
import pyglet
image = pyglet.image
from pyglet.graphics import TextureGroup
import pyglet.gl as gl

# local imports
import world_loader
import server_connection
import config
from config import SECTOR_SIZE, SECTOR_HEIGHT, LOADED_SECTORS
from util import normalize, sectorize, FACES, cube_v, cube_v2
from blocks import BLOCK_VERTICES, BLOCK_COLORS, BLOCK_NORMALS, BLOCK_TEXTURES, BLOCK_ID, BLOCK_SOLID, TEXTURE_PATH
import mapgen
import numpy

WATER = BLOCK_ID['Water']
#import logging
#logging.basicConfig(level = logging.INFO)
#def world_log(msg, *args):
#    logging.log(logging.INFO, 'WORLD: '+msg, *args)

class SectorProxy(object):
    def __init__(self, position, batch, group, model, shown=True):
        self.position = position[0],0,position[2]
        self.bposition = position[0]-1,0,position[2]-1 #block relative position (the sector is overgenerated by one block along each x,z edge)
        self.group = group
        self.model = model
        # A Batch is a collection of vertex lists for batched rendering.
        self.batch = batch
        self.blocks = numpy.zeros((SECTOR_SIZE+2,SECTOR_HEIGHT,SECTOR_SIZE+2),dtype='u2')
        self.shown = shown
        # Mapping from position to a pyglet `VertextList` for all shown blocks.
        self.vt = None
        self.vt_data = None
        self.invalidate_vt = False

    def draw(self, draw_invalid = True, allow_upload = True):
        if allow_upload and draw_invalid and self.invalidate_vt:
            self.check_show()
            self.invalidate_vt = False
            draw_invalid = False
        self.batch.draw()
        return draw_invalid

    def __getitem__(self, position):
        pos = position - numpy.array(self.bposition)
        if len(pos.shape)>1:
            pos = pos.T
            return self.blocks[pos[0],pos[1],pos[2]]
        return self.blocks[pos[0],pos[1],pos[2]]

    def invalidate(self):
        self.invalidate_vt = True

    def check_show(self,add_to_batch = True):
        if add_to_batch and self.vt_data is not None:
            if self.vt != None:
                print('deleting vt',self.position)
                self.vt.delete()
            (count, v, t, n, c) = self.vt_data
            # Convert quads to triangles for core profile and build a shader-driven vertex list
            quad_verts = numpy.array(v, dtype='f4').reshape(-1, 4, 3)
            quad_tex = numpy.array(t, dtype='f4').reshape(-1, 4, 2)
            quad_norm = numpy.array(n, dtype='f4').reshape(-1, 4, 3)
            quad_col = numpy.array(c, dtype='f4').reshape(-1, 4, 3)
            order = [0, 1, 2, 0, 2, 3]
            tri_verts = quad_verts[:, order, :].reshape(-1, 3)
            tri_tex = quad_tex[:, order, :].reshape(-1, 2)
            tri_norm = quad_norm[:, order, :].reshape(-1, 3)
            tri_col = quad_col[:, order, :].reshape(-1, 3)
            tri_count = len(tri_verts)
            self.vt = self.model.program.vertex_list(
                tri_count,
                gl.GL_TRIANGLES,
                batch=self.batch,
                group=self.group,
                position=('f', tri_verts.ravel().astype('f4')),
                tex_coords=('f', tri_tex.ravel().astype('f4')),
                normal=('f', tri_norm.ravel().astype('f4')),
                color=('f', tri_col.ravel().astype('f4')),
            )
            self.vt_data = None
        elif add_to_batch and self.vt_data is None and self.invalidate_vt:
            # Lazy rebuild when vt data was cleared for seam sync.
            self.model._recompute_vt(self)
            self.invalidate_vt = False
            return self.check_show(add_to_batch)


class ModelProxy(object):

    def __init__(self, program):

        # A TextureGroup manages an OpenGL texture.
        texture = image.load(TEXTURE_PATH).get_texture()
        self.program = program
        shader_group = pyglet.graphics.ShaderGroup(self.program)
        # Bind texture via TextureGroup under the shader group.
        self.group = TextureGroup(texture, parent=shader_group, order=0)
        self.unused_batches = []
        self.pending_uploads = deque()
        self.pending_upload_set = set()

        # The world is stored in sector chunks.
        self.sectors = {}
        self.update_sectors_pos = []
        self.update_ref_pos = None

        self.loader_requests = []
        self.active_loader_request = [None, None]
        self.n_requests = 0
        self.n_responses = 0
        self._skip_active_sector = False  # allow dropping a long-running sector load when edits arrive

        loader_server_pipe = None
        self.server = None
        if config.DEBUG_SINGLE_BLOCK:
            # Create a single sector with one visible block for debugging.
            batch = self.get_batch()
            s = SectorProxy((0,0,0), batch, self.group, self, shown=True)
            s.blocks[:] = 0
            cx, cy, cz = SECTOR_SIZE//2, SECTOR_HEIGHT//2, SECTOR_SIZE//2
            block_id = 1  # dirt
            s.blocks[cx+1, cy, cz+1] = block_id
            vt_data = self._build_block_vt(block_id, numpy.array([cx, cy, cz], dtype=numpy.float32))
            s.vt_data = vt_data
            s.check_show()
            self.sectors[s.position] = s
            self.loader = None
            print(f"[DEBUG] Single block spawned at world coords {(cx, cy, cz)}")
        else:
            if config.SERVER_IP is not None:
                print ('Starting server on %s'%(config.SERVER_IP,))
                self.server = server_connection.start_server_connection(config.SERVER_IP)
                loader_server_pipe = self.server.loader_pipe
            print ('Starting sector loader')
            self.loader = world_loader.start_loader(loader_server_pipe)

    def _has_budget(self, frame_start, upload_budget):
        if frame_start is None or upload_budget is None:
            return True
        return (time.perf_counter() - frame_start) < upload_budget

    def _queue_upload(self, sector):
        if sector not in self.pending_upload_set:
            self.pending_upload_set.add(sector)
            self.pending_uploads.append(sector)

    def process_pending_uploads(self, frame_start=None, upload_budget=None):
        """Upload queued sector vertex data while budget remains."""
        while self.pending_uploads and self._has_budget(frame_start, upload_budget):
            s = self.pending_uploads.popleft()
            self.pending_upload_set.discard(s)
            if s.vt_data is not None:
                s.check_show(add_to_batch=True)
            elif s.invalidate_vt:
                s.check_show(add_to_batch=True)
                s.invalidate_vt = False

    def _compute_exposed(self, blocks):
        air = (BLOCK_SOLID[blocks] == 0)
        solid = (blocks > 0) & (blocks != WATER)
        exposed_faces = numpy.zeros(blocks.shape + (6,), dtype=bool)
        exposed_faces[:,:-1,:,0] = air[:,1:,:]   # up
        exposed_faces[:,1:,:,1] = air[:,:-1,:]   # down
        exposed_faces[1:,:,:,2] = air[:-1,:,:]   # left
        exposed_faces[:-1,:,:,3] = air[1:,:,:]   # right
        exposed_faces[:,:,:-1,4] = air[:,:,1:]   # front
        exposed_faces[:,:,1:,5] = air[:,:,:-1]   # back
        exposed_faces = exposed_faces & solid[..., None]

        exposed_light = numpy.zeros(blocks.shape+(6,),dtype=numpy.float32)
        exposed_light[:,:-1,:,0] = 1.0
        exposed_light[:,1:,:,1] = 1.0
        exposed_light[1:,:,:,2] = 1.0
        exposed_light[:-1,:,:,3] = 1.0
        exposed_light[:,:,:-1,4] = 1.0
        exposed_light[:,:,1:,5] = 1.0
        return exposed_faces, exposed_light

    def _recompute_vt(self, sector):
        exposed_faces, exposed_light = self._compute_exposed(sector.blocks)
        exposed_faces = exposed_faces[1:-1,:,1:-1]
        exposed_light = exposed_light[1:-1,:,1:-1]

        sx, sy, sz, _ = exposed_faces.shape
        face_mask = exposed_faces.reshape(sx*sy*sz, 6)
        light_flat = exposed_light.reshape(sx*sy*sz, 6)
        block_mask = face_mask.any(axis=1)
        v = numpy.array([], dtype=numpy.float32)
        t = numpy.array([], dtype=numpy.float32)
        n = numpy.array([], dtype=numpy.float32)
        c = numpy.array([], dtype=numpy.float32)
        count = 0
        sector_grid = numpy.indices((SECTOR_SIZE, SECTOR_HEIGHT, SECTOR_SIZE)).transpose(1,2,3,0).reshape((SECTOR_SIZE*SECTOR_HEIGHT*SECTOR_SIZE,3))
        if block_mask.any():
            pos = sector_grid[block_mask] + numpy.array(sector.position)
            face_mask = face_mask[block_mask]
            light_flat = light_flat[block_mask]
            b = sector.blocks[1:-1,:,1:-1].reshape(sx*sy*sz)[block_mask]
            verts = (0.5*BLOCK_VERTICES[b].reshape(len(b),6,4,3) + pos[:,None,None,:]).astype(numpy.float32)
            tex = BLOCK_TEXTURES[b][:,:6].reshape(len(b),6,4,2).astype(numpy.float32)
            normals = numpy.broadcast_to(BLOCK_NORMALS[None,:,None,:], (len(b),6,4,3)).astype(numpy.float32)
            colors = BLOCK_COLORS[b][:,:6].reshape(len(b),6,4,3).astype(numpy.float32)
            v = verts[face_mask].reshape(-1,3).ravel()
            t = tex[face_mask].reshape(-1,2).ravel()
            n = normals[face_mask].reshape(-1,3).ravel()
            c = colors[face_mask].reshape(-1,3).ravel()
            count = len(v)//3
        # water surface quads (top only)
        water_top = numpy.zeros_like(sector.blocks, dtype=bool)
        water_top[:, :-1, :] = (sector.blocks[:, :-1, :] == WATER) & (sector.blocks[:, 1:, :] != WATER)
        water_top[:, -1, :] = (sector.blocks[:, -1, :] == WATER)
        wt_int = water_top[1:-1, :, 1:-1]
        wt_flat = wt_int.reshape(sx*sy*sz)
        if wt_flat.any():
            pos_w = sector_grid[wt_flat] + numpy.array(sector.position)
            wcount = len(pos_w)
            b = numpy.full(wcount, WATER, dtype=numpy.int32)
            verts = (0.5*BLOCK_VERTICES[b].reshape(wcount,6,4,3) + pos_w[:,None,None,:]).astype(numpy.float32)
            tex = BLOCK_TEXTURES[b][:,:6].reshape(wcount,6,4,2).astype(numpy.float32)
            normals = numpy.broadcast_to(BLOCK_NORMALS[None,:,None,:], (wcount,6,4,3)).astype(numpy.float32)
            colors = BLOCK_COLORS[b][:,:6].reshape(wcount,6,4,3).astype(numpy.float32)
            face_mask = numpy.zeros((wcount,6), dtype=bool)
            face_mask[:,0] = True

            wv = verts[face_mask].reshape(-1,3).ravel()
            wtcoords = tex[face_mask].reshape(-1,2).ravel()
            wn = normals[face_mask].reshape(-1,3).ravel()
            wc = colors[face_mask].reshape(-1,3).ravel()
            v = numpy.concatenate([v, wv])
            t = numpy.concatenate([t, wtcoords])
            n = numpy.concatenate([n, wn])
            c = numpy.concatenate([c, wc])
            count += len(wv)//3
        sector.vt_data = (count, v, t, n, c)
        sector.invalidate()

    def _sync_edges_and_rebuild(self, sector):
        # Copy boundary columns between this sector and loaded neighbors, then rebuild both.
        neighbors = list(self.neighbor_sectors(sector.position))
        for dx, dz, n in neighbors:
            if dx == 1:
                # neighbor to the east
                n.blocks[0,:,:] = sector.blocks[SECTOR_SIZE,:,:]
                sector.blocks[SECTOR_SIZE+1,:,:] = n.blocks[1,:,:]
            elif dx == -1:
                n.blocks[SECTOR_SIZE+1,:,:] = sector.blocks[1,:,:]
                sector.blocks[0,:,:] = n.blocks[SECTOR_SIZE,:,:]
            if dz == 1:
                # neighbor to the south (positive z)
                n.blocks[:,:,0] = sector.blocks[:,:,SECTOR_SIZE]
                sector.blocks[:,:,SECTOR_SIZE+1] = n.blocks[:,:,1]
            elif dz == -1:
                n.blocks[:,:,SECTOR_SIZE+1] = sector.blocks[:,:,1]
                sector.blocks[:,:,0] = n.blocks[:,:,SECTOR_SIZE]
            n.vt_data = None
            n.invalidate()
        sector.vt_data = None
        sector.invalidate()

    def set_matrices(self, projection, view):
        self.program['u_projection'] = numpy.array(projection, dtype='f4')
        self.program['u_view'] = numpy.array(view, dtype='f4')

    def get_batch(self):
        if len(self.unused_batches)>0:
            return self.unused_batches.pop(0)
        else:
            return pyglet.graphics.Batch()

    def release_sector(self, sector):
        if sector.vt is not None:
            sector.vt.delete()
        self.unused_batches.append(sector.batch)
        del self.sectors[sector.position]

    def __getitem__(self, position):
        """
        retrieves the block at the (x,y,z) coordinate tuple `position`
        """
        try:
            return self.sectors[sectorize(position)][position]
        except:
            return None

    def add_block(self, position, block, notify_server = True):
        spos = sectorize(position)
        if spos in self.sectors:
            s = self.sectors[spos]
            blocks = s.blocks
            sector_data = [(spos, blocks)]
            for np in [(1,0,0), (-1,0,0), (0,0,1), (0,0,-1)]:
                nspos = sectorize((position[0]+np[0],position[1]+np[1],position[2]+np[2]))
                if nspos != spos and nspos in self.sectors:
                    nblocks = self.sectors[nspos].blocks
                    sector_data.append((nspos, nblocks))
            # Purge queued background sector loads so edits jump the line.
            self.loader_requests = [req for req in self.loader_requests if req[0] != 'sector_blocks']
            # If the loader is busy with a sector load, mark it as skippable once it returns.
            if self.active_loader_request[0] == 'sector_blocks':
                self._skip_active_sector = True
            self.loader_requests.insert(0,['set_block', [notify_server, position, block, sector_data]])

    def remove_block(self, position, notify_server = True):
        pos = normalize(position)
        existing = self[pos]
        if existing == WATER:
            if not self._can_remove_water(pos):
                return
        self.add_block(pos, 0)
        # If we removed terrain below the waterline and there's adjacent water, flow in.
        if existing != WATER and pos[1] < self._water_level():
            if any(self[normalize((pos[0]+dx, pos[1]+dy, pos[2]+dz))] == WATER for dx, dy, dz in FACES):
                self.add_block(pos, WATER, notify_server)

    def _can_remove_water(self, pos):
        """Allow removal only if water pocket is smaller than 4 contiguous blocks."""
        seen = set()
        q = [pos]
        water_count = 0
        while q:
            cur = q.pop()
            if cur in seen:
                continue
            seen.add(cur)
            if self[cur] != WATER:
                continue
            water_count += 1
            if water_count >= 4:
                return False
            cx, cy, cz = cur
            for dx, dy, dz in FACES:
                npos = (cx + dx, cy + dy, cz + dz)
                if npos not in seen:
                    q.append(npos)
        return True

    def _water_level(self):
        return getattr(mapgen, 'GLOBAL_WATER_LEVEL', getattr(mapgen, 'WATER_LEVEL', 70))

    def draw(self, position, frustum_circle, frame_start=None, upload_budget=None, defer_uploads=False):
        """Draw only sectors intersecting the current view frustum projection. Limit or defer GPU uploads to respect frame budget."""
        draw_invalid = True

        def budget_ok():
            return self._has_budget(frame_start, upload_budget)

        for s in self.sectors.values():
            visible = self._sector_overlaps_frustum(s.position, frustum_circle)
            s.shown = visible
            if not visible:
                continue

            uploaded = False
            # Try to upload fresh vt_data if allowed; otherwise queue it.
            if s.vt_data is not None:
                if not defer_uploads and budget_ok():
                    s.check_show(add_to_batch=True)
                    self.pending_upload_set.discard(s)
                    uploaded = True
                else:
                    self._queue_upload(s)
            # Handle invalidated buffers (edge sync) within the budget or queue.
            elif draw_invalid and s.invalidate_vt:
                if not defer_uploads and budget_ok():
                    s.check_show(add_to_batch=True)
                    s.invalidate_vt = False
                    uploaded = True
                else:
                    self._queue_upload(s)

            if uploaded:
                draw_invalid = False
            # Draw existing batch; skip uploads here to honor the budget.
            draw_invalid = s.draw(draw_invalid, allow_upload=False)

        # Drain pending uploads while budget remains (only when not deferring).
        if not defer_uploads:
            self.process_pending_uploads(frame_start, upload_budget)

    def neighbor_sectors(self, pos):
        """
        return a tuple (dx, dz, sector) of currently loaded neighbors to the sector at pos
        """
        pos = sectorize(pos)
        for x in ((-1,0),(1,0),(0,-1),(0,1)):
            npos = (pos[0]+x[0]*SECTOR_SIZE,0,pos[2]+x[1]*SECTOR_SIZE)
            if npos in self.sectors:
                yield x[0],x[1],self.sectors[npos]

    def _sector_overlaps_frustum(self, sector_pos, frustum_circle):
        """Return True if the sector AABB intersects the 2D frustum circle."""
        if not frustum_circle:
            return True
        (center, rad) = frustum_circle
        cx, cz = center
        min_x = sector_pos[0] - 1
        max_x = sector_pos[0] + SECTOR_SIZE + 1
        min_z = sector_pos[2] - 1
        max_z = sector_pos[2] + SECTOR_SIZE + 1
        # Clamp circle center to sector bounds to find closest point
        nearest_x = min(max(cx, min_x), max_x)
        nearest_z = min(max(cz, min_z), max_z)
        dx = cx - nearest_x
        dz = cz - nearest_z
        return (dx * dx + dz * dz) <= (rad * rad)

    def _sector_priority(self, ref_sector, sector_pos, player_pos, look_vec):
        """Weight sector load priority by distance and look direction."""
        dist = (sector_pos[0] - ref_sector[0]) ** 2 + (sector_pos[2] - ref_sector[2]) ** 2
        if player_pos is None or look_vec is None:
            return float(dist)
        view = numpy.array([look_vec[0], look_vec[2]], dtype=float)
        vnorm = numpy.linalg.norm(view)
        if vnorm < 1e-5:
            return float(dist)
        view /= vnorm
        sector_center = numpy.array([sector_pos[0] + SECTOR_SIZE / 2.0,
                                     sector_pos[2] + SECTOR_SIZE / 2.0],
                                    dtype=float)
        to_sector = sector_center - numpy.array([player_pos[0], player_pos[2]], dtype=float)
        tnorm = numpy.linalg.norm(to_sector)
        if tnorm < 1e-5:
            facing = 1.0
        else:
            to_sector /= tnorm
            facing = float(numpy.dot(view, to_sector))
        angle_penalty = 1.0 - facing  # 0 front, 2 back
        return float(dist + angle_penalty * (SECTOR_SIZE ** 2))

    def update_sectors(self, old, new, player_pos=None, look_vec=None):
        """
        the observer has moved from sector old to new
        """
        if self.n_requests <= self.n_responses:
            new = sectorize(new)
            if self.update_ref_pos != new:
                self.update_ref_pos = new
                self.update_sectors_pos = []
                G = range(-LOADED_SECTORS,LOADED_SECTORS+1)
                for dx,dy,dz in itertools.product(G,(0,),G):
                    pos = numpy.array([new[0],new[1],new[2]]) \
                        + numpy.array([dx*SECTOR_SIZE,dy,dz*SECTOR_SIZE])
                    pos = sectorize(pos)
                    priority = self._sector_priority(new, pos, player_pos, look_vec)
                    if pos not in self.sectors and pos != self.active_loader_request[1]:
                        self.update_sectors_pos.append((priority,pos))
                for s in list(self.sectors):
                    if abs(new[0] - s[0])>LOADED_SECTORS*SECTOR_SIZE or abs(new[2] - s[2]) > LOADED_SECTORS*SECTOR_SIZE:
                        print('dropping sector',s,len(self.sectors))
                        self.release_sector(self.sectors[s])
                self.update_sectors_pos = sorted(self.update_sectors_pos)
            # If player edits are queued, defer background loads until they flush.
            pending_edit = any(r[0] == 'set_block' for r in self.loader_requests)
            if not pending_edit and len(self.update_sectors_pos)>0:
                self.active_loader_request = self.update_sectors_pos.pop(0)
                spos = self.active_loader_request[1]
                print('queueing sector',spos)
                try:
                    req_pos = [r[0] for r in self.loader_requests].index('sector_blocks') #insert job below higher priority jobs
                except ValueError:
                    req_pos = -1
                self.loader_requests.insert(req_pos,['sector_blocks',[spos]])
            if len(self.loader_requests)>0:
                self.loader_time = time.time()
                self.n_requests += 1
                print('client sending request to loader',self.loader_requests[0][0])
                self.loader.send(self.loader_requests.pop(0))

        if self.loader.poll():
            try:
                msg, data = self.loader.recv()
                print('client received',msg)
                if msg == 'sector_blocks':
                    spos1, b1, v1 = data
                    self.n_responses = self.n_requests
                    self.active_loader_request = [None, None]
                    print('took', time.time()-self.loader_time)
                    if self._skip_active_sector:
                        # Drop long-running background work when edits demand priority.
                        print('skipping sector result due to pending edits', spos1)
                        self._skip_active_sector = False
                    else:
                        self._update_sector(spos1, b1, v1)
                if msg == 'sector_blocks2':
                    self.n_responses = self.n_requests
                    self.active_loader_request = [None, None]
                    print('took', time.time()-self.loader_time)
                    for spos, b, v in data:
                        self._update_sector(spos, b, v)
            except EOFError:
                print('loader returned EOF')

        if self.server and self.server.poll():
            try:
                msg, data = self.server.recv()
                if msg == 'connected':
                    self.player, self.players = data
                if msg == 'player_set_block':
                    print(data)
                    pos, block = data
                    self.add_block(pos, block, False)
            except EOFError:
                print('server returned EOF')

    def _build_block_vt(self, block_id, pos):
        verts = (0.5*BLOCK_VERTICES[block_id][:6].reshape(6,4,3) + pos[None,None,:]).astype(numpy.float32)
        tex = BLOCK_TEXTURES[block_id][:6].reshape(6,4,2).astype(numpy.float32)
        normals = numpy.broadcast_to(BLOCK_NORMALS[:,None,:], (6,4,3)).astype(numpy.float32)
        colors = BLOCK_COLORS[block_id][:6].reshape(6,4,3).astype(numpy.float32)
        face_mask = numpy.ones((6,4), dtype=bool)
        v = verts[face_mask].reshape(-1,3).ravel().astype('f4')
        t = tex[face_mask].reshape(-1,2).ravel().astype('f4')
        n = normals[face_mask].reshape(-1,3).ravel().astype('f4')
        c = colors[face_mask].reshape(-1,3).ravel().astype('f4')
        count = len(v)//3
        if config.DEBUG_SINGLE_BLOCK:
            print("[DEBUG] block vertex sample:", v[:18], "tex:", t[:8])
        return count, v, t, n, c

    def _update_sector(self, spos, b, v):
        if b is not None:
            if spos in self.sectors:
                print('updating existing sector data',spos)
                s = self.sectors[spos]
                s.blocks[:,:,:] = b
                s.vt_data = v
                self._sync_edges_and_rebuild(s)
            else:
                print('setting new sector data',spos)
                s = SectorProxy(spos, self.get_batch(), self.group, self)
                s.blocks[:,:,:] = b
                s.vt_data = v
                self.sectors[sectorize(spos)] = s
                self._sync_edges_and_rebuild(s)

    def hit_test(self, position, vector, max_distance=8):
        """ Line of sight search from current position. If a block is
        intersected it is returned, along with the block previously in the line
        of sight. If no block is found, return None, None.

        Parameters
        ----------
        position : tuple of len 3
            The (x, y, z) position to check visibility from.
        vector : tuple of len 3
            The line of sight vector.
        max_distance : int
            How many blocks away to search for a hit.

        """
        m = 8
        x, y, z = position
        dx, dy, dz = vector
        previous = None
        for _ in range(max_distance * m):
            key = normalize((x, y, z))
            if key != previous:
                b = self[key]
                if b != 0 and b is not None:
                    return key, previous
            previous = key
            x, y, z = x + dx / m, y + dy / m, z + dz / m
        return None, None

    def measure_void_distance(self, position, vector, max_distance=64):
        """Return the number of solid blocks after the first hit until air along a ray.

        Starts from the current sight line, finds the first solid block, then steps
        block-by-block along the ray direction until the first air/void cell or until
        max_distance is exceeded. Returns None when no initial hit is found.
        """
        hit, _ = self.hit_test(position, vector, max_distance=max_distance)
        if not hit:
            return None

        hx, hy, hz = hit
        dx, dy, dz = vector
        length = math.sqrt(dx * dx + dy * dy + dz * dz)
        if length == 0:
            return None
        dirx, diry, dirz = dx / length, dy / length, dz / length

        # Start at center of hit block to avoid immediately re-hitting it.
        cellx, celly, cellz = hx, hy, hz
        px, py, pz = hx + 0.5, hy + 0.5, hz + 0.5
        step_x = 1 if dirx >= 0 else -1
        step_y = 1 if diry >= 0 else -1
        step_z = 1 if dirz >= 0 else -1

        invx = 1.0 / dirx if dirx != 0 else float("inf")
        invy = 1.0 / diry if diry != 0 else float("inf")
        invz = 1.0 / dirz if dirz != 0 else float("inf")

        t_max_x = ((cellx + (1 if step_x > 0 else 0)) - px) * invx if invx != float("inf") else float("inf")
        t_max_y = ((celly + (1 if step_y > 0 else 0)) - py) * invy if invy != float("inf") else float("inf")
        t_max_z = ((cellz + (1 if step_z > 0 else 0)) - pz) * invz if invz != float("inf") else float("inf")

        t_delta_x = abs(invx)
        t_delta_y = abs(invy)
        t_delta_z = abs(invz)

        traveled_blocks = 0
        t = 0.0
        max_steps = int(math.ceil(max_distance)) + 2

        for _ in range(max_steps):
            # advance to next voxel boundary
            if t_max_x < t_max_y:
                if t_max_x < t_max_z:
                    cellx += step_x
                    t = t_max_x
                    t_max_x += t_delta_x
                else:
                    cellz += step_z
                    t = t_max_z
                    t_max_z += t_delta_z
            else:
                if t_max_y < t_max_z:
                    celly += step_y
                    t = t_max_y
                    t_max_y += t_delta_y
                else:
                    cellz += step_z
                    t = t_max_z
                    t_max_z += t_delta_z

            if t > max_distance:
                break
            block = self[(cellx, celly, cellz)]
            if block == 0 or block is None:
                return traveled_blocks
            traveled_blocks += 1

        return traveled_blocks

    def exposed(self, position):
        """ Returns False is given `position` is surrounded on all 6 sides by
        blocks, True otherwise.

        """
        x, y, z = position
        for dx, dy, dz in FACES:
            b = self[normalize((x + dx, y + dy, z + dz))]
            if not BLOCK_SOLID[b]:
                return True
        return False

    def quit(self,kill_server=True):
        if self.n_requests > self.n_responses:
            self.loader.recv()
        print('shutting down loader')
        self.loader.send(['quit',0])
        if self.server is not None:
            print('closing server connection')
            self.server.send(['quit',0])

